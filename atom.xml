<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[bestalign's dev blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://bestalign.github.io/"/>
  <updated>2015-08-26T08:48:13.000Z</updated>
  <id>http://bestalign.github.io/</id>
  
  <author>
    <name><![CDATA[bestalign]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JavaScript 상속]]></title>
    <link href="http://bestalign.github.io/2015/08/02/JavaScript-Inheritance/"/>
    <id>http://bestalign.github.io/2015/08/02/JavaScript-Inheritance/</id>
    <published>2015-08-03T02:41:00.000Z</published>
    <updated>2015-08-26T08:48:13.000Z</updated>
    <content type="html"><![CDATA[<p>C++나 Java는 언어자체에서 상속을 위한 방법을 지원하는데 반해서 JavaScript는 이상하게도 특별히 상속을 위해 따로 지원하는 문법이 없다. 더욱이 class가 아닌 prototype을 이용해서 상속을 구현해야하기 때문에 코드가 다른 언어에 비해 길고 이해하기가 어렵다. Douglas Crockford는 이것에 관해서 JavaScript 자체가 prototype 컨셉을 완벽히 이해하고 있지 않다고 말했다 — <a href="https://youtu.be/ya4UHuXNygM?t=50m25s" target="_blank" rel="external">Crockford on JavaScript - Act III: Function the Ultimate 50분20초</a>. ECMAScript 2015(ES6)에서는 다행히 <em>class</em>와 함께 <em>extends</em> 키워드를 추가해서 쉽게 상속을 할 수 있게 되었다.</p>
<a id="more"></a>
<p>아래 코드는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript" target="_blank" rel="external">MDN Introduction to Object-Oriented JavaScript</a>의 코드가 이해하기 좋아서 가져왔다.</p>
<script src="//gist.github.com/aa5c1961616d496b476e.js?file=Inheritance.js"></script>
<h2 id="Line_18-22">Line 18-22</h2><p>Student의 생성자(constructor)를 만든다. Line 16에선 Student의 생성자 안에서 Person의 생성자를 호출한다. 이것은 Java의 super()와 같은 역할을 하는데, Person 생성자를 불러서 <code>firstname</code> property를 만들기 위해서이다 — <em>Student 생성자에서 직접 할 수도 있겠지만 그러면 상속의 의미가 없어진다.</em> super()와 한 가지 다른 건 call function을 사용해서 현재 Student 생성자의 context를 바인딩 한다는 점이다. 바인딩에 대한 내용은 나중에 다뤄보도록 하겠다.</p>
<h2 id="Line_25_-_26">Line 25 - 26</h2><p>JavaScript의 상속에서 가장 중요한 부분이다. <strong><code>Person.prototype</code>을 상속받기 위해 Student의 prototype를 업데이트한다.</strong> Person object를 만들어서 Student의 prototype으로 사용하게 되는데, 통째로 Person.prototype을 받으면서 Person의 생성자도 상속받게 되므로 다시 Student 생성자를 넣어준다.</p>
<p>코드를 보고 의문점이 두가지가 있었다.</p>
<p>그 중 하나는 새로운 Person object를 만들어서 사용한다는 것이었다. 왜냐하면 <code>Person.prototype</code>를 바로 prototype으로 사용하는게 속도 면에서 좋기 때문이다. Person object를 만들어서 사용하는 것과 <code>Person.prototype</code>을 사용해서 Student object를 만들었을때 Prototype chaining은 다음과 같다.</p>
<script src="//gist.github.com/aa5c1961616d496b476e.js?file=prototype_inheritance_prototype_chaining.txt"></script>
<p>하지만 Line 26에서 생성자를 업데이트 하는 것을 보고 바로 그 이유를 알았다. 만약 <code>Person.prototype</code>을 Student의 prototype으로 사용할 경우 Student 생성자를 업데이트 해버리면 Person의 생성자까지 같이 바뀌어버리기 때문이다. 또, Line 28-35에서 <code>Student.prototype</code>에 function을 더 추가하는데 마찬가지로 <code>Person.prototype</code>의 값을 바꿔버리게 된다.</p>
<p>두 번째 의문은 Person object를 만들 때 <code>new Person()</code>을 사용하지 않고 <strong>생성자를 호출하지 않는</strong> <code>Object.create(Person.prototype)</code>를 사용한다는 점이었다. 이건 아주 단순한 이유였는데, 각각의 Student object가 <code>firstname</code> property를 가져야하기 때문이다. <code>firstname</code> property는 Student 생성자에서 값이 정해져야 하므로 — <em>Line 18-22에서 설명했듯이 Person 생성자는 Student 생성자 내에서 호출된다</em> — Student의 prototype을 만드는 이곳에서는 <code>Object.create(Person.prototype)</code>를 사용해야만 한다.</p>
<p>다시 말해보자면 <strong>Person object를 만들었다고 생각하는 것보다 <code>Person.prototype</code>을 상속받는 prototype object를 새로 하나 만든다고 생각하는게 이해하기 더 쉽다.</strong> </p>
<h2 id="Line_28-31">Line 28-31</h2><p><code>Person.prototype</code>에서 선언 된 <code>sayHello</code> 함수를 재정의 한다. <code>Student.prototype</code>에 새로운 이름이 같은 다른 함수를 선언 하는 것 뿐이며 <code>Person.prototype</code>의 <code>sayHello</code> 함수는 Property Shadowing에 의해 가려진다.</p>
<ul>
<li>참고글: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript" target="_blank" rel="external">MDN Introduction to Object-Oriented JavaScript</a></li>
<li>참고동영상: <a href="https://youtu.be/ya4UHuXNygM?t=50m25s" target="_blank" rel="external">Crockford on JavaScript - Act III: Function the Ultimate 50분20초</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>C++나 Java는 언어자체에서 상속을 위한 방법을 지원하는데 반해서 JavaScript는 이상하게도 특별히 상속을 위해 따로 지원하는 문법이 없다. 더욱이 class가 아닌 prototype을 이용해서 상속을 구현해야하기 때문에 코드가 다른 언어에 비해 길고 이해하기가 어렵다. Douglas Crockford는 이것에 관해서 JavaScript 자체가 prototype 컨셉을 완벽히 이해하고 있지 않다고 말했다 — <a href="https://youtu.be/ya4UHuXNygM?t=50m25s">Crockford on JavaScript - Act III: Function the Ultimate 50분20초</a>. ECMAScript 2015(ES6)에서는 다행히 <em>class</em>와 함께 <em>extends</em> 키워드를 추가해서 쉽게 상속을 할 수 있게 되었다.</p>]]>
    
    </summary>
    
      <category term="Inheritance" scheme="http://bestalign.github.io/tags/Inheritance/"/>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/tags/JavaScript/"/>
    
      <category term="property shadowing" scheme="http://bestalign.github.io/tags/property-shadowing/"/>
    
      <category term="prototype chain" scheme="http://bestalign.github.io/tags/prototype-chain/"/>
    
      <category term="상속" scheme="http://bestalign.github.io/tags/%EC%83%81%EC%86%8D/"/>
    
      <category term="자바스크립트" scheme="http://bestalign.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="프로토타입 체인" scheme="http://bestalign.github.io/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8/"/>
    
      <category term="프로퍼티 쉐도잉" scheme="http://bestalign.github.io/tags/%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%89%90%EB%8F%84%EC%9E%89/"/>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Prototype Chain and Property Shadowing]]></title>
    <link href="http://bestalign.github.io/2015/07/28/Prototype-Chain/"/>
    <id>http://bestalign.github.io/2015/07/28/Prototype-Chain/</id>
    <published>2015-07-28T07:29:53.000Z</published>
    <updated>2015-08-26T08:46:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Prototype_Chain">Prototype Chain</h1><p><strong>JavaScript의 Prototype Chain은 <em>[[Prototype]]</em>으로 이루어지는 object들의 연결을 말한다.</strong> JavaScript의 Primitive Type을 제외한 모든 object는 <em>[[Prototype]]</em>을 가지고 있으며 그 연결된 Prototype Chain은 마치 Linked List 처럼 생겼다. Prototype Chain의 마지막은 항상 <code>Object.prototype</code>에서 끝나며, <code>Object.prototype</code>의 <em>[[Prototype]]</em>은 일반적인 Linked List처럼 null로 끝난다.<br><a id="more"></a></p>
<script src="//gist.github.com/99cb16fbee2e48e748c2.js?file=prototype_chain.js"></script>
<p>위의 코드는 <code>A_Prototype</code>을 만들고 거기서 A라는 instance를 생성하는 것을 보여준다. 이 object와 prototype의 Prototype Chain을 그래프로 간략히 그려보면 다음과 같다.</p>
<script src="//gist.github.com/99cb16fbee2e48e748c2.js?file=prototype_chain_example.js"></script>
<p>위의 예제에 써 있듯이 <code>A</code>, <code>A_Prototype</code>, <code>Object.prototype</code>, <code>null</code>순으로 Prototype Chain이 연결된다. <code>Object.prototype</code>에는 아주 많은 property가 있지만 가독성을 위해 생략했다. JavaScript engine은 object의 property를 접근할 때 그 object의 property 뿐만이 아니라 상황에 따라 Prototype Chain으로 연결된 상위 object의 property까지 확인하게 된다.</p>
<p>위의 예제에서 <code>A.z</code>는 <code>A</code>의 property이므로 바로 3을 출력한다. <code>A.x</code>와 <code>A.y</code>같은 경우는 <code>A</code>가 가지고 있지 않은 property이기 때문에 Prototype Chain을 거슬러 올라가면서 확인하게 되며, <code>A_Prototype</code>의 property인 <code>A_Prototype.x</code>, <code>A_Prototype.y</code>의 값인 1, 2를 출력하게 된다. <code>A.x</code>와 <code>A.y</code>는 <code>A_Prototype</code>에게서 상속받았다고 볼 수 있다.</p>
<p>마지막으로 <code>A.a</code>는 위의 Prototype Chain에 있는 어느 object에도 존재하지 않는 property이다. JavaScript engine은 Prototype Chain의 끝인 <code>Object.prototype</code>까지 확인한 뒤 <code>undefined</code>를 출력하게 된다.</p>
<h1 id="Property_Shadowing">Property Shadowing</h1><p>위의 Prototype Chain 예제에서는 <code>A</code>와 <code>A_Prototype</code> 모두 겹치지 않는 property를 가지고 있다. 만약 이들 중 이름이 겹치는 property가 존재한다면 무슨 일이 일어날까?</p>
<script src="//gist.github.com/99cb16fbee2e48e748c2.js?file=property_shadowing.js"></script>
<p>JavaScript engine은 특정 property를 찾을 때 <strong>주어진 object부터</strong> Prototype Chain을 따라 상위로 올라가면서 property를 확인하고 가장 먼저 찾은 property를 가져온다. 이런 방식으로 동작하기 때문에 상위 object에 같은 이름의 property가 존재한다고 해도 무시하게 된다. 이것을 바로 Property Shadowing이라고 부른다.</p>
<script src="//gist.github.com/99cb16fbee2e48e748c2.js?file=property_shadowing_example.js"></script>
<p>Property Shadowing에 의해서 Line 9에서는 <code>A_Prototype.x</code>의 값인 1을 상속받지 않고 <code>A.x</code>의 값인 4를 출력한다. Variable뿐만이 아니라 Function도 똑같이 object의 property가 될 수 있으므로 Prototype Chain과 Property Shadowing의 영향 하에 있다. 이를 이용해서 JavaScript에서는 <em>class</em>나 <em>extends</em> 키워드 없이 function overriding과 object inheritance를 구현한다.</p>
<ul>
<li>관련글: <a href="/2015/08/26/JavaScript-Prototype/" title="JavaScript Prototype">JavaScript Prototype</a></li>
<li>참고글: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="external">MDN Inheritance and the Prototype Chain</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Prototype_Chain">Prototype Chain</h1><p><strong>JavaScript의 Prototype Chain은 <em>[[Prototype]]</em>으로 이루어지는 object들의 연결을 말한다.</strong> JavaScript의 Primitive Type을 제외한 모든 object는 <em>[[Prototype]]</em>을 가지고 있으며 그 연결된 Prototype Chain은 마치 Linked List 처럼 생겼다. Prototype Chain의 마지막은 항상 <code>Object.prototype</code>에서 끝나며, <code>Object.prototype</code>의 <em>[[Prototype]]</em>은 일반적인 Linked List처럼 null로 끝난다.<br>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/tags/JavaScript/"/>
    
      <category term="property shadowing" scheme="http://bestalign.github.io/tags/property-shadowing/"/>
    
      <category term="prototype chain" scheme="http://bestalign.github.io/tags/prototype-chain/"/>
    
      <category term="자바스크립트" scheme="http://bestalign.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="프로토타입 체인" scheme="http://bestalign.github.io/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8/"/>
    
      <category term="프로퍼티 쉐도잉" scheme="http://bestalign.github.io/tags/%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%89%90%EB%8F%84%EC%9E%89/"/>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[new와 prototype]]></title>
    <link href="http://bestalign.github.io/2015/07/20/new-prototype/"/>
    <id>http://bestalign.github.io/2015/07/20/new-prototype/</id>
    <published>2015-07-20T17:33:56.000Z</published>
    <updated>2015-08-26T08:50:56.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript에서도 다른 여타 언어들처럼 instance를 생성할 떄 new를 사용한다. JavaScript는 prototype으로 instance를 생성해야 하기 때문에 Java나 C++같은 언어와는 다른 방식을 가지고 있다. 내부적으로 어떤식으로 동작하는지 궁금해서 검색해보다가 <a href="https://en.wikipedia.org/wiki/Douglas_Crockford" target="_blank" rel="external">Douglas Crockford</a>의 책 <em>JavaScript: The Good Parts</em>에 좋은 코드가 있어서 가져와보았다. 아래의 코드는 new가 keyword가 아니라 function이라고 가정했을 떄 적어본 것이다.<br><a id="more"></a></p>
<script src="//gist.github.com/5111bb2e85c5b348f189.js?file=new-fuction.js"></script>
<p>object를 생성할 때 쓰인 Object.create()는 완전히 빈 object를 만들어서 거기에다가 단순히 prototype을 연결시키는 역할을 한다. 위의 line 13의 코드를 바꿔보자면 다음과 같다.</p>
<script src="//gist.github.com/5111bb2e85c5b348f189.js?file=object-create.js"></script>
<p>이렇게 만들어진 <em>new function</em>을 이용하면 아래와 같이 new를 사용하지 않고 새로운 instance를 만들 수 있다.</p>
<script src="//gist.github.com/5111bb2e85c5b348f189.js?file=point-new.js"></script>
<p>Douglas Crockford는 <em>JavaScript: The Good Parts</em>에서 new을 사용하는 것에 대해서 부정적인 입장을 보였다. 혹시나 개발자가 실수로 new를 사용하는 것을 잊어버리면 instance생성이 아닌 일반적인 function 호출이 되어버려서 생성자 내부에서 쓰이는 this가 global로 바인딩 되어버리기 때문이다. JavaScript engine는 컴파일/런타임 때 아무런 오류를 보여주지 않기 때문에 더욱 문제가 된다. 실제로 많은 사람들이 이 문제로 많은 버그를 겪었고, ECMAScript5부터 <strong>strict mode</strong>를 지원해서 바인딩없이 function이 호출될 경우 this가 undefined로 바인딩되도록 하였다.</p>
<p>다른 것보다도 class가 없는 JavaScript에 Java/C++와 같이 new를 사용하도록 만들었다는 것 자체가 문제라고 본다. prototype을 기반으로 한 훨씬 이해하기 쉬운 instance 생성 문법도 있었을텐데, Java랑 비슷한 문법으로 된 건 그 당시 Netscape의 정책 때문이라고 알고 있다. 열 흘만에 만들어진 언어의 숙명이랄까. 멀리 갈 것도 없이 나부터 바로 이해가 안돼서 이런 글을 쓰게 되었으니.. ES6부터는 아예 class keyword를 지원해서 훨씬 직관적으로 class를 선언하고 instance를 생성할 수 있게 되었다 — 당연하게도 prototype기반 언어인 것은 변함이 없다. <a href="http://www.2ality.com/" target="_blank" rel="external">Dr. Axel Rauschmayer</a>가 적은 글 중에 ES6의 class에 대한 좋은 글이 있는데 나중에 한 번 다뤄볼 생각이다.</p>
<ul>
<li>참고글:<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">MDN - JavaScript Object.create()</a></li>
<li><a href="http://stackoverflow.com/questions/7962886/how-does-object-create-work-in-javascript" target="_blank" rel="external">StackOverflow - How does Object.create work in JavaScript</a></li>
</ul>
</li>
<li>관련글: <a href="/2015/08/26/JavaScript-Prototype/" title="JavaScript Prototype">JavaScript Prototype</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript에서도 다른 여타 언어들처럼 instance를 생성할 떄 new를 사용한다. JavaScript는 prototype으로 instance를 생성해야 하기 때문에 Java나 C++같은 언어와는 다른 방식을 가지고 있다. 내부적으로 어떤식으로 동작하는지 궁금해서 검색해보다가 <a href="https://en.wikipedia.org/wiki/Douglas_Crockford">Douglas Crockford</a>의 책 <em>JavaScript: The Good Parts</em>에 좋은 코드가 있어서 가져와보았다. 아래의 코드는 new가 keyword가 아니라 function이라고 가정했을 떄 적어본 것이다.<br>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/tags/JavaScript/"/>
    
      <category term="new" scheme="http://bestalign.github.io/tags/new/"/>
    
      <category term="prototype" scheme="http://bestalign.github.io/tags/prototype/"/>
    
      <category term="자바스크립트" scheme="http://bestalign.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="프로토타입" scheme="http://bestalign.github.io/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/"/>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Lexical Scope in JavaScript]]></title>
    <link href="http://bestalign.github.io/2015/07/12/Lexical-Scope-in-JavaScript/"/>
    <id>http://bestalign.github.io/2015/07/12/Lexical-Scope-in-JavaScript/</id>
    <published>2015-07-13T03:33:56.000Z</published>
    <updated>2015-08-26T08:43:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Lexical_Scope_and_Dynamic_Scope">Lexical Scope and Dynamic Scope</h1><p>C/C++, Java, 그리고 JavaScript 같이 우리가 접하는 대부분의 언어들은 Lexical Scope를 사용한다. Lexical Scope는 Static Scope라고도 불린다. 반대의 방식으로는 Dynamic Scope가 있으며 Perl, Bash Shell, APL 같은 몇몇 오래된 언어들이 사용하는 방식이다. 두 방식의 정의는 다음과 같다.</p>
<blockquote>
<p><strong>Lexical scope</strong>: use [context] where function [and variable] is defined<br><strong>Dynamic scope</strong>: use [context] where function [and variable] is called<br>출처: <a href="https://courses.cs.washington.edu/courses/cse341/14sp/slides/lec09.pdf" target="_blank" rel="external">University of Washington CSE341 2014 Spring - Lecture 9</a></p>
</blockquote>
<a id="more"></a> 
<p>Lexical Scope는 변수나 함수가 <strong>정의 된 곳</strong>의 context를 사용하며, Dynamic Scope는 변수나 함수가 <strong>불려진 곳</strong>의 context를 사용한다. Lexical Scope는 아주 익숙한 개념이므로 Dynamic Scope에 대해서만 간단히 설명하고, Lexical Scope가 JavaScript에서 어떻게 쓰이는 지 적어볼까 한다.</p>
<h2 id="Dynamic_Scope">Dynamic Scope</h2><script src="//gist.github.com/a6e917597435ef5734f9.js?file=javascript_dynamic_scope.js"></script>
<p>위의 코드는 JavaScript에 Dynamic Scope가 적용되었다고 가정했다. — <em>실제로 실행할 경우 다른 결과값이 나온다</em>. 모든 결과값은 Line 3의 <strong>x의 값을 읽은 타이밍</strong>에 따라서 — 이름 그대로 동적으로 — 달라진다. Line 12에서 처음으로 <em>foo function</em>이 호출될 때 x의 값은 10이므로 당연히 결과값은 10이 출력된다. Line 13에서도 x의 값은 10이지만 <em>bar function</em>내에서 x를 15으로 재선언 뒤 <em>foo function</em>을 호출하기 때문에 결과값이 15로 바뀌게 된다.</p>
<h1 id="언어에_따른_Lexical_Scope의_차이">언어에 따른 Lexical Scope의 차이</h1><h2 id="Block_Scope">Block Scope</h2><p>C계열의 언어들은 모든 block이 자신의 scope를 가진다.</p>
<script src="//gist.github.com/a6e917597435ef5734f9.js?file=block_scope.c"></script>
<p>if block 자체가 자신의 scope를 가지고 있으므로 <strong>main function의 scope</strong>에는 영향없이 따로 x의 값을 가질 수 있다. if block이 지난 뒤에는 다시 <strong>main function의 scope</strong>에 접근하게 된다.</p>
<h2 id="Function_Scope">Function Scope</h2><p>JavaScript는 Function Scope를 사용한다. function만이 자신의 scope를 가진다.</p>
<script src="//gist.github.com/a6e917597435ef5734f9.js?file=function_scope_if_block.js"></script>
<p>Block Scope와 JavaScript에서는 <strong>function만이 scope를 가지기 때문에</strong> if block 안에서 x값을 수정하면 <strong>foo function의 scope</strong>의 x에 값이 바뀌게 된다 — <em>실제 JavaScript의 if block 안에서 var를 다시 선언하는 건 좋은 코딩스타일은 아니다</em>. 그러므로, if block이 끝난 뒤에도 수정된 값을 가지게 된다.</p>
<h1 id="그럼_JavaScript에서_새_Scope_생성은?">그럼 JavaScript에서 새 Scope 생성은?</h1><p>당연한 이야기지만 Function Scope를 생성해야 하므로 필요한 곳에 function을 추가하면 된다.</p>
<script src="//gist.github.com/a6e917597435ef5734f9.js?file=function_scope_iife.js"></script>
<p>예제와 같은 경우는 if block의 한정된 곳에서 한번만 실행 될 코드이므로 Immediately-Invoked Function Expression(IIFE)를 추가한다. IIFE는 만들어지자마자 바로 실행되며 동시에 새로운 scope를 가진다. 독립적인 scope를 가지므로 그 안에서 선언된 x는 <strong>foo function의 scope</strong>에 영향을 미치지 않는다.</p>
<p>JavaScript에서 function을 이용한 Lexical Scope는 Closure를 이해하는데 아주 중요한 요소 중 하나이며 그 외에도 모듈화를 하는데도 빈번히 사용된다.</p>
<h1 id="Let_keyword_in_ES6">Let keyword in ES6</h1><p>이번에 제정된 ES6(ECMAScript 2015)에서는 let keyword가 새로 추가되었다. var과 비슷하게 변수를 선언하는 keyword이지만 많은 부분에서 차이를 보인다.</p>
<ul>
<li>var keyword<ul>
<li>Function Scope</li>
<li>Hoisting</li>
<li>중복선언 가능</li>
</ul>
</li>
<li>let keyword<ul>
<li>Block Scope</li>
<li>NO Hoisting</li>
<li>중복선언 불가 (에러 발생)</li>
</ul>
</li>
</ul>
<p>참고글:</p>
<ul>
<li><a href="https://courses.cs.washington.edu/courses/cse341/14sp/" target="_blank" rel="external">University of Washington CSE341 2014 Spring</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="external">MDN JavaScript let</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Lexical_Scope_and_Dynamic_Scope">Lexical Scope and Dynamic Scope</h1><p>C/C++, Java, 그리고 JavaScript 같이 우리가 접하는 대부분의 언어들은 Lexical Scope를 사용한다. Lexical Scope는 Static Scope라고도 불린다. 반대의 방식으로는 Dynamic Scope가 있으며 Perl, Bash Shell, APL 같은 몇몇 오래된 언어들이 사용하는 방식이다. 두 방식의 정의는 다음과 같다.</p>
<blockquote>
<p><strong>Lexical scope</strong>: use [context] where function [and variable] is defined<br><strong>Dynamic scope</strong>: use [context] where function [and variable] is called<br>출처: <a href="https://courses.cs.washington.edu/courses/cse341/14sp/slides/lec09.pdf">University of Washington CSE341 2014 Spring - Lecture 9</a></p>
</blockquote>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/tags/JavaScript/"/>
    
      <category term="lexical" scheme="http://bestalign.github.io/tags/lexical/"/>
    
      <category term="lexical scope" scheme="http://bestalign.github.io/tags/lexical-scope/"/>
    
      <category term="scope" scheme="http://bestalign.github.io/tags/scope/"/>
    
      <category term="렉시컬" scheme="http://bestalign.github.io/tags/%EB%A0%89%EC%8B%9C%EC%BB%AC/"/>
    
      <category term="렉시컬 스코프" scheme="http://bestalign.github.io/tags/%EB%A0%89%EC%8B%9C%EC%BB%AC-%EC%8A%A4%EC%BD%94%ED%94%84/"/>
    
      <category term="스코프" scheme="http://bestalign.github.io/tags/%EC%8A%A4%EC%BD%94%ED%94%84/"/>
    
      <category term="자바스크립트" scheme="http://bestalign.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript Prototype]]></title>
    <link href="http://bestalign.github.io/2015/07/07/JavaScript-Prototype/"/>
    <id>http://bestalign.github.io/2015/07/07/JavaScript-Prototype/</id>
    <published>2015-07-07T09:27:32.000Z</published>
    <updated>2015-08-26T08:43:08.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript의 prototype를 처음부터 다시 공부하면서 적어보았다. C/C++와 Java로 프로그래밍을 시작했고 오래써왔기 때문에 prototype을 이해하는데 꽤 오랜시간이 걸렸다. 둘 다 상속, 캡슐화, 추상화, 다형성 등을 전부 지원하지만 접근하는 방식은 좀 다를 뿐 깊게 들어가보면 동작하는 방식은 대동소이하다. Java와 비교하면서 적었기 때문에 Java를 쓰시는 분이면 이해하기 쉬울 듯하다.<br><a id="more"></a></p>
<h1 id="Java_Class와_JavaScript_Prototype">Java Class와 JavaScript Prototype</h1><h2 id="Java_Class">Java Class</h2><script src="//gist.github.com/6e1969ee79b189bef332.js?file=JavaClassDeclaration.java"></script>
<p>Java는 class를 <strong>설계도</strong>삼아 object를 만들어낸다. 위의 코드에서는 Point class instance인 <em>p1</em>, <em>p2</em>가 생성된다. 메모리 관점에서 봤을 때 완전히 똑같은 object 두 개가 따로 메모리 상에 저장된다.</p>
<h2 id="JavaScript_Prototype">JavaScript Prototype</h2><script src="//gist.github.com/6e1969ee79b189bef332.js?file=javascript_prototype_declaration.js"></script>
<p>JavaScript 코드는 Java 코드와 비교하면서 한 줄 한 줄 설명해 해보았다.</p>
<h3 id="Line_2_~_5">Line 2 ~ 5</h3><p>Java에서 <em>class</em>키워드를 사용해서 class를 선언하는데 비해서, JavaScript에서는 먼저 생성자(constructor)를 만든다. <em>Point function</em>이 선언됨과 동시에 <strong>Point function object</strong>가 생성된다 — <em>JavaScript에서는 function도 object로 관리된다.</em> <strong>Point function object</strong>의 내부에는 <em>prototype</em>이라는 property가 자동적으로 생성된다. 이게 바로 Point의 prototype이다. prototype은 메모리 상에 존재하는 <strong>object</strong>이며 거기서 생성/파생되는 모든 object의 <strong>원형</strong>이 된다. 기본으로 만들어 지는 prototype은 아무런 값이 없는 object이다 — 보든 JavaScript의 Object가 그렇듯 prototype object도 <em>Object.prototype</em>을 기반으로 한 object이다.</p>
<p><strong>생성자</strong>인 <em>Point function</em> 에서는 일반적으로 property를 만들고 초기화하는 일을 한다. Java에서는 x, y field<sup>1</sup> 를 class 내에 따로 선언하지만 JavaScript는 따로 property<sup>1</sup> 선언은 하지 않고 <strong>생성자</strong> 내에서 <code>this.x = x</code>처럼 값을 넣어서 선언 및 초기화 한다. <strong>생성자에서 추가 된 property는 prototype과는 상관없이 각 object에 종속된다.</strong></p>
<h3 id="Line_8_~_10">Line 8 ~ 10</h3><p><em>print method</em>를 Point의 prototype에 추가한다. 이것은 Java의 print method와 같은 역할을 하게 된다. <strong>prototype에 추가 된 method와 property는 이후에 생성된 모든 instance에서 접근이 가능하다.</strong></p>
<h3 id="Line_14_~_15">Line 14 ~ 15</h3><p>Line 14-15에서는 <em>new</em>키워드로 Point instance <em>p1</em>, <em>p2</em>를 생성한다. 내부적으로 동작하는 걸 자세히 따져보면 C/C++나 Java같은 instance화 라기보다는 <strong>prototype을 가리키는 빈 object를 만드는 것에 가깝다.</strong></p>
<p><em>p1</em>과 <em>p2</em>는 아주 단순한 구조를 가지고 있다. 빈 object에 x, y property를 가지고 있고, 거기에 추가로 숨겨진 property인 <em>[[Prototype]]</em>를 가진다 — Chrome, Safari 등 많은 모던브라우저에서는 <em>__proto__</em>라는 이름을 사용하고 있지만 ECMAScript 표준은 <em>[[Prototype]]</em>이다. </p>
<p>두 instance의 <em>[[Prototype]]</em>은 모두 <em>Person.prototype</em>를 가리킨다. 간단히 말해, <strong><em>p1</em>과 <em>p2</em>는 하나의 prototype object를 공유한다.</strong> 이렇게 prototype object를 공유함으로써 Prototype Chain과 Property Shadowing이 가능해진다.</p>
<svg width="320" height="320" xmlns="http://www.w3.org/2000/svg"><defs><marker refy="50" refx="50" markerheight="5" markerwidth="5" viewbox="0 0 100 100" se_type="rightarrow" orient="auto" markerunits="strokeWidth" id="se_marker_end_svg_6"><path stroke-width="10" stroke="#000000" fill="#000000" d="m100,50l-100,40l30,-40l-30,-40z"/></marker><marker refy="50" refx="50" markerheight="5" markerwidth="5" viewbox="0 0 100 100" se_type="rightarrow" orient="auto" markerunits="strokeWidth" id="se_marker_end_svg_11"><path stroke-width="10" stroke="#000000" fill="#000000" d="m100,50l-100,40l30,-40l-30,-40z"/></marker></defs><g><title>JavaScript prototype</title><rect id="svg_2" height="80" width="160" y="40" x="80" stroke-width="2" stroke="#000000" fill="none"/><text xml:space="preserve" text-anchor="middle" font-family="Nanum Gothic" font-size="20" id="svg_3" y="60" x="160" stroke-linecap="null" stroke-linejoin="null" stroke-width="0" stroke="#000000" fill="#000000">Point.prototype</text><rect id="svg_4" height="80" width="130" y="200" x="10" stroke-linecap="null" stroke-linejoin="null" stroke-width="2" stroke="#000000" fill="none"/><rect id="svg_5" height="80" width="130" y="200" x="180" stroke-linecap="null" stroke-linejoin="null" stroke-width="2" stroke="#000000" fill="none"/><line y="NaN" x="NaN" marker-end="url(#se_marker_end_svg_6)" id="svg_6" y2="130" x2="140" y1="200" x1="80" stroke-linecap="null" stroke-linejoin="null" stroke-width="2" stroke="#000000" fill="none"/><text xml:space="preserve" text-anchor="middle" font-family="Nanum Gothic" font-size="20" id="svg_9" y="220" x="80" stroke-linecap="null" stroke-linejoin="null" stroke-width="0" stroke="#000000" fill="#000000">p1</text><text xml:space="preserve" text-anchor="middle" font-family="Nanum Gothic" font-size="20" id="svg_10" y="220" x="250" stroke-linecap="null" stroke-linejoin="null" stroke-width="0" stroke="#000000" fill="#000000">p2</text><line marker-end="url(#se_marker_end_svg_11)" id="svg_11" y2="130" x2="180" y1="200" x1="230" stroke-linecap="null" stroke-linejoin="null" stroke-width="2" stroke="#000000" fill="none"/><text xml:space="preserve" text-anchor="middle" font-family="Nanum Gothic" font-size="20" id="svg_12" y="260" x="70" stroke-linecap="null" stroke-linejoin="null" stroke-width="0" stroke="#000000" fill="#000000">x:0, y:0</text><text id="svg_13" xml:space="preserve" text-anchor="middle" font-family="Nanum Gothic" font-size="20" y="260" x="240" stroke-linecap="null" stroke-linejoin="null" stroke-width="0" stroke="#000000" fill="#000000">x:5, y:5</text><text xml:space="preserve" text-anchor="middle" font-family="Nanum Gothic" font-size="20" id="svg_14" y="90" x="160" stroke-linecap="null" stroke-linejoin="null" stroke-width="0" stroke="#000000" fill="#000000">print function</text></g></svg>

<ul>
<li>관련글<ul>
<li><a href="/2015/07/20/new-prototype/" title="New와 Prototype">New와 Prototype</a></li>
<li><a href="/2015/07/28/Prototype-Chain/" title="Prototype Chain">Prototype Chain</a>
</li>
</ul>
</li>
</ul>
<hr>
<p>[1]: Java에서는 field, JavaScript에서는 property</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript의 prototype를 처음부터 다시 공부하면서 적어보았다. C/C++와 Java로 프로그래밍을 시작했고 오래써왔기 때문에 prototype을 이해하는데 꽤 오랜시간이 걸렸다. 둘 다 상속, 캡슐화, 추상화, 다형성 등을 전부 지원하지만 접근하는 방식은 좀 다를 뿐 깊게 들어가보면 동작하는 방식은 대동소이하다. Java와 비교하면서 적었기 때문에 Java를 쓰시는 분이면 이해하기 쉬울 듯하다.<br>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/tags/JavaScript/"/>
    
      <category term="class" scheme="http://bestalign.github.io/tags/class/"/>
    
      <category term="instance" scheme="http://bestalign.github.io/tags/instance/"/>
    
      <category term="object" scheme="http://bestalign.github.io/tags/object/"/>
    
      <category term="prototype" scheme="http://bestalign.github.io/tags/prototype/"/>
    
      <category term="객체" scheme="http://bestalign.github.io/tags/%EA%B0%9D%EC%B2%B4/"/>
    
      <category term="오브젝트" scheme="http://bestalign.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"/>
    
      <category term="인스턴스" scheme="http://bestalign.github.io/tags/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4/"/>
    
      <category term="자바스크립트" scheme="http://bestalign.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="클래스" scheme="http://bestalign.github.io/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"/>
    
      <category term="프로토타입" scheme="http://bestalign.github.io/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/"/>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript Data Types]]></title>
    <link href="http://bestalign.github.io/2015/06/29/JavaScript-Data-Type/"/>
    <id>http://bestalign.github.io/2015/06/29/JavaScript-Data-Type/</id>
    <published>2015-06-29T08:20:21.000Z</published>
    <updated>2015-08-26T08:40:47.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript data type은 다음과 같다. 5개의 primitive type — 얼마전에 새로 나온 <em>ECMAScript 6</em>의 스펙에서는 symbol type이 추가 — 그리고 하나의 object type있다. primitive type은 가장 기본적이고 단순한 값을 가지며 들어가는 모든 값들은 immutable이다.</p>
<ul>
<li>primitive type<ul>
<li>undefined type</li>
<li>null type</li>
<li>boolean type</li>
<li>number type</li>
<li>string type</li>
</ul>
</li>
<li>object type<a id="more"></a> 
<h2 id="undefined_type">undefined type</h2>undefined type은 단 하나의 값 <em>undefined</em>을 가지고 있다. type 이름과 거기에 들어가는 값의 이름이 같다.</li>
</ul>
<p><em>undefined</em>는 새로 선언된 variable의 기본값으로 들어간다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// undefined의 type은 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="comment">// x의 안에 들어있는 값이 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="null_type">null type</h2><p>undefined type 처럼, null type은 단 하나의 값 <em>null</em>을 가지고 있다. 타입 이름과 거기에 들어가는 값의 이름이 같다.</p>
<p>하지만 실제로 브라우저에서 <em>null</em>의 type을 확인해보면 <code>&quot;object&quot;</code>라고 출력된다. 이것은 JavaScript 엔진 초기버전의 버그였는데 하위 호환성을 위해서 고쳐지지 못했다. 아마 영원히 고쳐질일은 없을 듯 하다.. 자세한 내용을 알고 싶으면 <a href="http://www.2ality.com/2013/10/typeof-null.html" target="_blank" rel="external">이 링크(영문)</a>에 자세한 설명이 있다.</p>
<p><em>null</em>은 빈 값이라는 것을 의도적으로 보이기 위해 넣는 값이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// object - 버그!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = <span class="literal">null</span>; <span class="comment">// no data</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="literal">null</span>; <span class="comment">// no object</span></span><br></pre></td></tr></table></figure>
<h2 id="boolean_type">boolean type</h2><p><em>true</em>/<em>false</em>의 type.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">false</span>); <span class="comment">// boolean</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> &lt; <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="number">2</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="number_type">number type</h2><p>정수, 실수, +/- <em>Infinity</em>, <em>NaN</em>(not-a-number)이 모두 number type이다. JavaScript는 C/C++나 Java와 달리 단 하나의 숫자 type을 가지고 있다.</p>
<p>JavaScript는 숫자를 표현하기 위해서 <a href="http://en.wikipedia.org/wiki/Double_precision_floating-point_format" target="_blank" rel="external">IEEE 754 standard</a>를 사용하고 있다. 정수형/실수형을 위해 개별적인 방식은 제공되지 않고 모두 한가지 방식으로 표현된다. 숫자하나당 8 byte로 정수를 저장하기에 조금 비효율적이긴 하지만 개발할 때는 타입을 신경안써도 되기때문에 편하다는 장점이 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">0.3</span>); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">Infinity</span>); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> -<span class="literal">Infinity</span>); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">NaN</span>); <span class="comment">// number</span></span><br></pre></td></tr></table></figure>
<h2 id="string_type">string type</h2><p>모든 문자열의 type.</p>
<p>JavaScript의 문자열은 Java와 같이 immutable로 일단 생성되면 값을 바꿀 수 없다. 대신 그 문자열에서 새로운 문자열을 만들어 낼 수는 있다. 내부적으로 16-bit unsigned integer set으로 저장된다.</p>
<p>String literal을 만들때는 큰따옴표 혹은 작은따옴표로 원하는 문자열을 감싸서 만들 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">"hello world!"</span>); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'hello world!'</span>); <span class="comment">// string</span></span><br></pre></td></tr></table></figure>
<h2 id="object_type">object type</h2><p>모든 객체의 type. <del>또한 null의 type.</del></p>
<p>JavaScript에는 기본적으로 탑재된 객체가 아주 많다. 모든 JavaScript 객체들의 조상인 <em>Object</em>부터 <em>Array</em>, <em>Date</em>, <em>RegExp</em>, <em>Function</em>, 그리고 Primitive type의 wrapper인 <em>Booean</em>, <em>Number</em>, <em>String</em> 까지 모두 object type이다.</p>
<p>object에 관련해서는 너무나 많은 내용이 있기 때문에 따로 글을 써볼 생각이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<p>참조글: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures" target="_blank" rel="external">MDN JavaScript data types and data structures</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript data type은 다음과 같다. 5개의 primitive type — 얼마전에 새로 나온 <em>ECMAScript 6</em>의 스펙에서는 symbol type이 추가 — 그리고 하나의 object type있다. primitive type은 가장 기본적이고 단순한 값을 가지며 들어가는 모든 값들은 immutable이다.</p>
<ul>
<li>primitive type<ul>
<li>undefined type</li>
<li>null type</li>
<li>boolean type</li>
<li>number type</li>
<li>string type</li>
</ul>
</li>
<li>object type]]>
    
    </summary>
    
      <category term="Data Type" scheme="http://bestalign.github.io/tags/Data-Type/"/>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/tags/JavaScript/"/>
    
      <category term="Primitive" scheme="http://bestalign.github.io/tags/Primitive/"/>
    
      <category term="데이터 타입" scheme="http://bestalign.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85/"/>
    
      <category term="자바스크립트" scheme="http://bestalign.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Github pages로 블로그를 열었습니다]]></title>
    <link href="http://bestalign.github.io/2015/06/25/hello-world/"/>
    <id>http://bestalign.github.io/2015/06/25/hello-world/</id>
    <published>2015-06-26T03:33:56.000Z</published>
    <updated>2015-08-26T09:11:47.000Z</updated>
    <content type="html"><![CDATA[<p>보통 공부하는 내용들을 따로 정리하거나 하는 편은 아닌데 기록으로 남기고 공유해보고 싶다는 생각이 들어서 만들어보게 되었습니다. 일반적으로 Github Pages를 만들 때 Jekyll을 많이 쓰는데 저는 단지 요즘 JavaScript에 꽂혀있는 관계로 Node.js 기반인 Hexo를 이용해서 블로그를 만들어 보았습니다. Jekyll은 Ruby기반인데 별로 써본적이 없어서 불편하기도 하구요.</p>
<p>기본 셋업에 Hexo 사이트에 올라와 있는 Theme을 적용해서 좀 밋밋합니다. 계속 조금씩 업데이트해서 부족하나마 개성을 줘 볼 생각입니다. 바닥부터 새로 만들어 볼까도 생각해봤는데 그러기엔 시간이 너무 걸릴 것 같네요.</p>
<p>아마 블로깅의 대부분은 개발에 대한 내용이 되지 않을까 싶습니다. JavaScript, Java, CSS 등등 — 특히나 프론트엔드 — 일하면서 새로 배우는 내용이라던가 개발관련 번역이라던가 이것저것 생각하고 있습니다.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>보통 공부하는 내용들을 따로 정리하거나 하는 편은 아닌데 기록으로 남기고 공유해보고 싶다는 생각이 들어서 만들어보게 되었습니다. 일반적으로 Github Pages를 만들 때 Jekyll을 많이 쓰는데 저는 단지 요즘 JavaScript에 꽂혀있는]]>
    </summary>
    
      <category term="잡담" scheme="http://bestalign.github.io/categories/%EC%9E%A1%EB%8B%B4/"/>
    
  </entry>
  
</feed>
