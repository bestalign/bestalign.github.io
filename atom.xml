<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[bestalign's dev blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://bestalign.github.io/"/>
  <updated>2015-09-02T08:38:09.000Z</updated>
  <id>http://bestalign.github.io/</id>
  
  <author>
    <name><![CDATA[bestalign]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[자바 프로그래머가 자주 실수 하는 10가지 - 2]]></title>
    <link href="http://bestalign.github.io/2015/09/02/top-10-mistakes-java-developers-make-2/"/>
    <id>http://bestalign.github.io/2015/09/02/top-10-mistakes-java-developers-make-2/</id>
    <published>2015-09-02T08:38:09.000Z</published>
    <updated>2015-09-02T08:38:09.000Z</updated>
    <content type="html"><![CDATA[<p>원문: <a href="http://www.programcreek.com/2014/05/top-10-mistakes-java-developers-make/" target="_blank" rel="external">http://www.programcreek.com/2014/05/top-10-mistakes-java-developers-make/</a></p>
<p>이전글: <a href="/2015/08/31/top-10-mistakes-java-developers-make-1/" title="자바 프로그래머가 자주 실수하는 10가지 - 1">자바 프로그래머가 자주 실수하는 10가지 - 1</a></p>
<h3 id="#6-_접근_레벨">#6. 접근 레벨</h3><p>개발자들은 꽤 자주 public 클래스 필드를 사용한다. 외부에서 아주 간단하게 필드 값에 접근을 할 수 있지만, 이건 아주 안 좋은 디자인이다. 제대로 된 디자인은 각 멤버들에게 가능한한 낮은 접근 레벨을 주는 것이다.</p>
<p><a href="http://www.programcreek.com/2011/11/java-access-level-public-protected-private/" target="_blank" rel="external">public, default, protected, and protected</a></p>
<a id="more"></a>
<h3 id="#7-_ArrayList_vs-_Linked_List">#7. ArrayList vs. Linked List</h3><p><code>ArrayList</code>와 <code>LinkedList</code>의 차이를 모를 때 종종 그냥 더 익숙해 보이는 <code>ArrayList</code>를 사용하곤 한다. 하지만, 이 선택은 아주 큰 성능 차이를 불러온다. 간단히 말해서, <code>LinkedList</code>는 임의 접근(Random Access)이 별로 없고 값의 추가/삭제가 많을 때 사용하는 것이 적당하다. 이 자세한 내용은 <a href="http://www.programcreek.com/2013/03/arraylist-vs-linkedlist-vs-vector/" target="_blank" rel="external">ArrayList vs. LinkedList</a>에서 알 수 있다.</p>
<h3 id="#8-_Mutable_vs-_Immutable">#8. Mutable vs. Immutable</h3><p>Immutable 객체는 심플함, 안전성 등에서 많은 장점을 가지고 있다. 하지만 각각 다른 값을 위해 새로운 객체를 생성해야 하고, 그 때문에 가비지컬렉션(garbage collection)에 부하를 줄 가능성이 있다. mutable과 immutable중에서 선택할 때는 필요해 따라 잘 선택해야 한다.</p>
<p>일반적으로, mutable 객체는 하나의 객체를 만들기 위해 값을 많이 바꿀 필요가 있을 경우에 사용한다. 예를 들어, 많은 문자열(String)을 이어붙여야 할 경우, 만약 immutable 문자열을 사용한다면 매번 문자열을 이을 때마다 가비지컬렉터로 처리되어야 할 필요없는 객체가 생성 될 것이다. 이것은 쓸데 없이 CPU의 시간과 에너지를 소비시킨다. 이런 곳에서는 mutable 객체를 사용하는 것이 바른 해결책이다 (예: <code>StringBuilder</code>)</p>
<script src="//gist.github.com/f0b9adf2595105effeb3.js?file=mutable-vs-immutable.java"></script>
<p>mutable 객체를 사용하는 것이 필요한 상황들이 있다. 예를 들면, mutable 객체들을 매서드에 매개변수로 넘겨주면 고생할 필요없이 한 번에 다수의 결과를 돌려받을 수 있다. 또 다른 예로는, 정렬과 필터링이다. 당연히 일반적인 collection을 받고 정렬된 새로운 collection을 리턴하도록 메서드를 만들 수도 있지만, 아주 큰 collection이라면 아주 낭비일 것이다. (Stack Overflow <a href="http://stackoverflow.com/questions/23616211/why-we-need-mutable-classes" target="_blank" rel="external">dasblinkenlight의 답변</a>)</p>
<p><a href="http://www.programcreek.com/2013/04/why-string-is-immutable-in-java/" target="_blank" rel="external">Why String is Immutable?</a></p>
<h3 id="#9-_Super와_Sub의_생성자(Constructor)">#9. Super와 Sub의 생성자(Constructor)</h3><script src="//gist.github.com/f0b9adf2595105effeb3.js?file=constructor-of-super-and-sub-wrong.java"></script>
<p>위의 컴파일 에러는 Super의 기본 생성자가 정의되어 있지 않기 때문이다. 자바에서는, 생성자가 없는 클래스가 있다면 컴파일러가 자동으로 아무런 매개변수를 받지않는 디폴트 생성자를 생성해준다. 만약 어떤 생성자든 Super 클래스에 정의되어 있다면 – 지금의 경우 Super(String s) – 디폴트 생성자를 자동으로 만들어 주지 않는다. 이것이 바로 위의 Super 클래스의 상황이다.</p>
<p>위의 두 Sub 클래스의 생성자는 Super 클래스의 디폴트 생성자를 호출할 것이다. 컴파일러는 Sub 클래스의 생성자 내부에 <code>super()</code>를 자동으로 추가하지만 Super의 디폴트 생성자는 존재하지 않기 때문에 에러가 나게된다.</p>
<p>이 문제를 해결하기 위해서는, 1) 아래와 같이 <code>Super()</code> 생성자를 Super 클래스에 추가하거나</p>
<script src="//gist.github.com/f0b9adf2595105effeb3.js?file=constructor-of-super-and-sub-right.java"></script>
<p>, 또는 2) 정의 되어 있는 Super 클래스의 생성자를 없애거나, 혹은 <code>super(value)</code>를 Sub 클래스의 각 생성자에 추가해주면 된다.</p>
<h3 id="#10-_“”_아니면_생성자?">#10. “” 아니면 생성자?</h3><p>문자열은 두 방법으로 생성할 수 있다:</p>
<script src="//gist.github.com/f0b9adf2595105effeb3.js?file=quote-or-constructor-1.java"></script>
<p>여기서의 차이는 무엇일까?</p>
<p>다음의 예제에서 쉽게 확인할 수 있다.</p>
<script src="//gist.github.com/f0b9adf2595105effeb3.js?file=quote-or-constructor-2.java"></script>
<p>문자열이 메모리에 어떻게 저장되는지에 대한 더욱 자세한 내용은 <a href="http://www.programcreek.com/2014/03/create-java-string-by-double-quotes-vs-by-constructor/" target="_blank" rel="external">Create Java String Using “” or Constructor?</a>에서 볼 수 있다.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>원문: <a href="http://www.programcreek.com/2014/05/top-10-mistakes-java-developers-make/">http://www.programcreek.com/2014/05/top-10-mistakes-java-developers-make/</a></p>
<p>이전글: <a href="/2015/08/31/top-10-mistakes-java-developers-make-1/" title="자바 프로그래머가 자주 실수하는 10가지 - 1">자바 프로그래머가 자주 실수하는 10가지 - 1</a></p>
<h3 id="#6-_접근_레벨">#6. 접근 레벨</h3><p>개발자들은 꽤 자주 public 클래스 필드를 사용한다. 외부에서 아주 간단하게 필드 값에 접근을 할 수 있지만, 이건 아주 안 좋은 디자인이다. 제대로 된 디자인은 각 멤버들에게 가능한한 낮은 접근 레벨을 주는 것이다.</p>
<p><a href="http://www.programcreek.com/2011/11/java-access-level-public-protected-private/">public, default, protected, and protected</a></p>]]>
    
    </summary>
    
      <category term="Java" scheme="http://bestalign.github.io/tags/Java/"/>
    
      <category term="mistake" scheme="http://bestalign.github.io/tags/mistake/"/>
    
      <category term="실수" scheme="http://bestalign.github.io/tags/%EC%8B%A4%EC%88%98/"/>
    
      <category term="자바" scheme="http://bestalign.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="번역" scheme="http://bestalign.github.io/categories/%EB%B2%88%EC%97%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[자바 프로그래머가 자주 실수 하는 10가지 - 1]]></title>
    <link href="http://bestalign.github.io/2015/08/31/top-10-mistakes-java-developers-make-1/"/>
    <id>http://bestalign.github.io/2015/08/31/top-10-mistakes-java-developers-make-1/</id>
    <published>2015-09-01T04:30:49.000Z</published>
    <updated>2015-09-02T08:37:07.000Z</updated>
    <content type="html"><![CDATA[<p>원문: <a href="http://www.programcreek.com/2014/05/top-10-mistakes-java-developers-make/" target="_blank" rel="external">http://www.programcreek.com/2014/05/top-10-mistakes-java-developers-make/</a></p>
<p>다음글: <a href="/2015/09/02/top-10-mistakes-java-developers-make-2/" title="자바 프로그래머가 자주 실수하는 10가지 - 2">자바 프로그래머가 자주 실수하는 10가지 - 2</a></p>
<h3 id="#1-_일반_배열을_ArrayList로_변환하기">#1. 일반 배열을 ArrayList로 변환하기</h3><p>보통 많은 개발자가 다음과 같이 일반 배열을 <code>ArrayList</code>로 변환한다:</p>
<script src="//gist.github.com/f0b9adf2595105effeb3.js?file=convert-array-to-arraylist-wrong.java"></script>
<a id="more"></a>
<p><code>Arrays.asList()</code>는 <code>Arrays</code>의 private 정적 클래스인 <code>ArrayList</code>를 리턴한다. <code>java.util.ArrayList</code> 클래스와는 다른 클래스이다. <code>java.util.Arrays.ArrayList</code> 클래스는 <code>set()</code>, <code>get()</code>, <code>contains()</code> 매서드를 가지고 있지만 원소를 추가하는 매서드는 가지고 있지 않기 때문에 사이즈를 바꿀 수 없다. 진짜 <code>ArrayList</code>를 받기 위해서는 다음과 같이 변환하면 된다:</p>
<script src="//gist.github.com/f0b9adf2595105effeb3.js?file=convert-array-to-arraylist-right.java"></script>
<p><code>ArrayList</code>의 생성자는 <code>java.util.Arrays.ArrayList</code>의 상위(super) 클래스인 Collection type도 받아들일 수 있다.</p>
<h3 id="#2-_일반_배열에_특정_값이_들어있는지_확인하기">#2. 일반 배열에 특정 값이 들어있는지 확인하기</h3><p>보통 이렇게 많이 확인한다:</p>
<script src="//gist.github.com/f0b9adf2595105effeb3.js?file=check-if-an-array-contains-a-value-wrong.java"></script>
<p>이 코드는 동작하지만 list를 set으로 변환하는 것은 시간도 더 걸릴뿐더러 사실 할 필요가 없다. 대신에 다음과 같이 처리할 수 있다:</p>
<script src="//gist.github.com/f0b9adf2595105effeb3.js?file=check-if-an-array-contains-a-value-right.java"></script>
<p>첫번째 솔루션이 훨씬 읽기 편하다.</p>
<h3 id="#3-_Loop에서_list의_원소를_제거하기">#3. Loop에서 list의 원소를 제거하기</h3><p>다음과 같이 Loop 안에서 원소를 제거한다고 하자:</p>
<script src="//gist.github.com/f0b9adf2595105effeb3.js?file=remove-an-element-from-a-list-inside-a-loop-wrong1.java"></script>
<p>위의 코드에는 아주 심각한 문제가 있다. 원소가 삭제될 때, list의 사이즈가 줄어들면서 다른 원소들의 index도 바뀌어 버린다. 그래서 만약 loop 내에서 다수의 원소를 index를 사용해 삭제한다면 생각한대로 동작하지 않을 것이다.</p>
<p>아마 반복자(iterator)를 사용하는 것이 바른 방법이고, foreach loop가 내부적으로 반복자를 사용한다는 것을 알고 있을지도 모른다. 하지만 사실 다음의 foreach loop에서도 올바르게 동작하지 않는다:</p>
<script src="//gist.github.com/f0b9adf2595105effeb3.js?file=remove-an-element-from-a-list-inside-a-loop-wrong2.java"></script>
<p>위의 코드는 <code>ConcurrentModificationException</code>을 발생시킬 것이다.</p>
<p>다음의 코드는 제대로 동작한다:</p>
<script src="//gist.github.com/f0b9adf2595105effeb3.js?file=remove-an-element-from-a-list-inside-a-loop-right.java"></script>
<p>반드시 <code>.remove()</code>전에 <code>.next()</code>가 호출되어야 한다. 만약 foreach loop안에서 원소가 삭제된 뒤에 <code>.next()</code>가 호출된다면 컴파일러는 <code>ConcurrentModificationException</code>을 발생시킬 것이다. <code>ArrayList.iterator()</code>의 코드가 깊이 이해하는 데 도움이 될 것이다.</p>
<h3 id="#4-_Hashtable_vs_HashMap">#4. Hashtable vs HashMap</h3><p>알고리즘적으로 봤을 때 Hashtable은 자료구조 이름이지만 Java에서의 이름은 사실 <code>HashMap</code>이다. <code>Hashtable</code>이 <code>HashMap</code>과 가장 다른 점은 바로 동기화(synchronized)라는 것이다. 그래서 대부분 <code>Hashtable</code>보다는 <code>HashMap</code>을 사용하는 것이 좋다.</p>
<p><a href="http://www.programcreek.com/2013/03/hashmap-vs-treemap-vs-hashtable-vs-linkedhashmap/" target="_blank" rel="external">HashMap vs. TreeMap vs. Hashtable vs. LinkedHashMap</a><br><a href="http://www.programcreek.com/2013/09/top-9-questions-for-java-map/" target="_blank" rel="external">Top 10 questions about Map</a></p>
<h3 id="#5-_Collection의_Raw_Type_사용">#5. Collection의 Raw Type 사용</h3><p>Java에서는, <em>raw type</em>과 <em>unbounded wildcard type</em>이 쉽게 섞여서 함께 사용된다. Set을 예로 들어보면, <code>Set</code>은 raw type이고 <code>Set&lt;?&gt;</code>은 unbounded wildcard type이다.</p>
<p>다음과 같은 raw type <code>List</code>를 파라미터로 사용하는 코드가 있다고 하자:</p>
<script src="//gist.github.com/f0b9adf2595105effeb3.js?file=use-raw-type-of-collection.java"></script>
<p>raw type collection을 사용하는 것은 타입 체크를 건너뛰기 때문에 안전하지 않다. <code>Set</code>, <code>Set&lt;?&gt;</code>, <code>Set&lt;Object&gt;</code> 사이에는 아주 큰 차이가 있다. 다음 글들을 읽는 걸 추천한다.</p>
<p><a href="http://www.programcreek.com/2013/12/raw-type-set-vs-unbounded-wildcard-set/" target="_blank" rel="external">Raw type vs. Unbounded wildcard</a><br><a href="http://www.programcreek.com/2011/12/java-type-erasure-mechanism-example/" target="_blank" rel="external">Type Erasure</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>원문: <a href="http://www.programcreek.com/2014/05/top-10-mistakes-java-developers-make/">http://www.programcreek.com/2014/05/top-10-mistakes-java-developers-make/</a></p>
<p>다음글: <a href="/2015/09/02/top-10-mistakes-java-developers-make-2/" title="자바 프로그래머가 자주 실수하는 10가지 - 2">자바 프로그래머가 자주 실수하는 10가지 - 2</a></p>
<h3 id="#1-_일반_배열을_ArrayList로_변환하기">#1. 일반 배열을 ArrayList로 변환하기</h3><p>보통 많은 개발자가 다음과 같이 일반 배열을 <code>ArrayList</code>로 변환한다:</p>
<script src="//gist.github.com/f0b9adf2595105effeb3.js?file=convert-array-to-arraylist-wrong.java"></script>]]>
    
    </summary>
    
      <category term="Java" scheme="http://bestalign.github.io/tags/Java/"/>
    
      <category term="mistake" scheme="http://bestalign.github.io/tags/mistake/"/>
    
      <category term="실수" scheme="http://bestalign.github.io/tags/%EC%8B%A4%EC%88%98/"/>
    
      <category term="자바" scheme="http://bestalign.github.io/tags/%EC%9E%90%EB%B0%94/"/>
    
      <category term="번역" scheme="http://bestalign.github.io/categories/%EB%B2%88%EC%97%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OS X Bash 키보드 단축키]]></title>
    <link href="http://bestalign.github.io/2015/08/30/osx-bash-keyboard-shortcuts/"/>
    <id>http://bestalign.github.io/2015/08/30/osx-bash-keyboard-shortcuts/</id>
    <published>2015-08-30T09:03:11.000Z</published>
    <updated>2015-08-31T09:39:01.000Z</updated>
    <content type="html"><![CDATA[<p>원본: <a href="http://ss64.com/osx/syntax-bashkeyboard.html" target="_blank" rel="external">http://ss64.com/osx/syntax-bashkeyboard.html</a></p>
<p>이미 아시는 분들도 많겠지만 Emacs의 단축키 중 어느정도가 OS X 터미널에서 사용이 가능하다. 나도 조금은 사용을 하고 있었지만 한 번 제대로 써보자 하는 생각이 들어서 정리를 하게 되었다. 정확히 어떤 단축키를 지원하는지 잘 몰라서 구글링을 좀 했는데 꽤 잘 정리된 포스팅이 있어서 번역해 보았다. 직접 OS X Yosemite에서 직접 테스트하면서 작성했고, 더 이해하기 쉽게 세부 카테고리를 나누어서 정리했다. 그리고 원본이 오래되어서 그런지 몰라도 실행이 안되는 경우도 있었는데, 거의 쓰이지 않는 단축키들이라서 그냥 리스트에 포함시키지 않았다.<br><a id="more"></a></p>
<p>사용 전에 Alt키의 설정을 조금 손 봐야한다. 아래의 스크린샷처럼 터미널의 키보드 설정에서 Alt키를 Meta키로 사용하는 걸로 바꿔주면 된다. iTerm이나 다른 터미널 어플리케이션에서도 대부분 지원하는 옵션이다.<br><img src="/2015/08/30/osx-bash-keyboard-shortcuts/opt_meta_key.png" alt="Option키를 Meta키로 변경" title="Option키를 Meta키로 변경"></p>
<h2 id="커서_이동:">커서 이동:</h2><ul>
<li>Ctrl + a:  라인의 처음</li>
<li>Ctrl + e:   라인의 끝</li>
<li>Alt + b:   커서의 왼쪽 단어 (Option+Right-Arrow)</li>
<li>Alt + f:   커서의 오른쪽 단어 (Option+Left-Arrow)</li>
<li>Ctrl + f:   다음 캐릭터 (Right arrow)</li>
<li>Ctrl + b:   이전 캐릭터 (Left arrow)</li>
<li>Ctrl + xx:  라인의 처음과 현재 커서 위치를 토글</li>
</ul>
<h2 id="편집:">편집:</h2><h3 id="-_삭제">- 삭제</h3><ul>
<li>Alt + backspace: 커서의 왼쪽 단어를 삭제</li>
<li>Alt + d:   커서의 오른쪽 단어를 삭제</li>
<li>Ctrl + d:   커서가 위치한 곳의 캐릭터를 삭제</li>
<li>Ctrl + h:   커서의 왼쪽에 있는 캐릭터를 삭제 (backspace)</li>
</ul>
<h3 id="-_잘라내기/붙여넣기">- 잘라내기/붙여넣기</h3><ul>
<li>Ctrl + w:   커서의 왼쪽에 있는 단어를 잘라내기</li>
<li>Ctrl + k:   커서의 오른쪽을 모두 잘라내기</li>
<li>Ctrl + u:   커서의 왼쪽을 모두 잘라내기</li>
<li>Ctrl + y:   마지막으로 잘라냈던 걸 붙여넣기 (yank)</li>
</ul>
<h3 id="-_수정">- 수정</h3><ul>
<li>Ctrl + t:   커서아래의 캐릭터와 커서 바로 왼쪽의 캐릭터의 위치를 바꾸기</li>
<li>Alt + t:   커서아래의 단어와 바로 이전 단어의 위치를 바꾸기</li>
<li>Esc  + t:   커서 왼쪽의 두 단어의 위치를 바꾸기</li>
<li>Alt + u:   현재 커서위치에서 현재 단어의 끝까지의 캐릭터를 대문자로 바꾸기</li>
<li>Alt + l:   현재 커서위치에서 현재 단어의 끝까지의 캐릭터를 소문자로 바꾸기</li>
<li>Alt + c:   현재 커서위치의 캐릭터를 대문자로, 나머지 캐릭터는 소문자로 바꾸고 단어의 끝으로 커서를 이동</li>
</ul>
<h3 id="-_그_외">- 그 외</h3><ul>
<li>Alt + r:   (다음/이전 커맨드 사용중) 편집을 취소하고 히스토리의 초기 상태로 돌린다</li>
<li>Ctrl + _:   Undo (편집 한 것을 하나씩 취소)</li>
<li>Ctrl + l:   화면을 클리어 (clear와 비슷함)</li>
<li>TAB       파일/디렉터리 이름 자동완성</li>
</ul>
<h2 id="히스토리:">히스토리:</h2><ul>
<li>Ctrl + p:   이전 커맨드 (Up arrow)</li>
<li>Ctrl + n:   다음 커맨드 (Down arrow)</li>
<li>Alt + .:   바로 이전 커맨드에서 마지막 단어를 가져오기</li>
<li>Ctrl + r:   이전 커맨드 히스토리에서 커맨드 검색하기</li>
<li>Ctrl + g:   검색모드에서 나오기</li>
<li>Ctrl + o:   커맨드 실행하기<ul>
<li>초기 설정에서는 사용할 수 없다. ~/.bash_profile에 <code>stty discard undef</code>를 추가한 후 터미널 재시동이 필요하다</li>
<li>return/enter 대신 사용할 수 있다</li>
</ul>
</li>
</ul>
<h2 id="프로세스_컨트롤:">프로세스 컨트롤:</h2><ul>
<li>Ctrl + c:   현재 화면에서 실행중인 프로세스를 Kill/Interrupt  (SIGINT)</li>
<li>Ctrl + d:   (옵션에서 비활성화 되어있지 않다면) EOF 시그널을 보낸다. 현재 쉘이 닫힐 것이다 (EXIT)</li>
<li>Ctrl + z:   SIGTSTP 시그널로 현재 화면에서 실행중인 프로세스를 suspend 시킨다<ul>
<li>fg ‘프로세스 이름’ 으로 suspend 된 프로세스를 가져올 수 있다</li>
</ul>
</li>
</ul>
<h3 id="Emacs_모드_vs_Vi_모드">Emacs 모드 vs Vi 모드</h3><p>기본적으로 Bash에서 Emacs의 단축키를 지원하지만 Vi로 바꿀 수 있는 방법이 있다.</p>
<h4 id="Vi_모드_변경">Vi 모드 변경</h4><p><code>$ set -o vi</code></p>
<h4 id="Emacs_모드_변경">Emacs 모드 변경</h4><p><code>$ set -o emacs</code></p>
<p><a href="http://ss64.com/docs/copyright.html" target="_blank" rel="external">원본의 라이센스</a>에 따라서 이 글은 다음과 같은 라이센스를 갖는다.</p>
<p><a rel="external" href="http://creativecommons.org/licenses/by-nc-sa/2.0/uk/" target="_blank"><img alt="크리에이티브 커먼즈 라이선스" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-sa/2.0/uk/88x31.png"></a><br>이 저작물은 <a rel="external" href="http://creativecommons.org/licenses/by-nc-sa/2.0/uk/" target="_blank">크리에이티브 커먼즈 저작자표시-비영리-동일조건변경허락 2.0 영국(잉글랜드, 웨일즈) 라이선스</a>에 따라 이용할 수 있습니다.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>원본: <a href="http://ss64.com/osx/syntax-bashkeyboard.html">http://ss64.com/osx/syntax-bashkeyboard.html</a></p>
<p>이미 아시는 분들도 많겠지만 Emacs의 단축키 중 어느정도가 OS X 터미널에서 사용이 가능하다. 나도 조금은 사용을 하고 있었지만 한 번 제대로 써보자 하는 생각이 들어서 정리를 하게 되었다. 정확히 어떤 단축키를 지원하는지 잘 몰라서 구글링을 좀 했는데 꽤 잘 정리된 포스팅이 있어서 번역해 보았다. 직접 OS X Yosemite에서 직접 테스트하면서 작성했고, 더 이해하기 쉽게 세부 카테고리를 나누어서 정리했다. 그리고 원본이 오래되어서 그런지 몰라도 실행이 안되는 경우도 있었는데, 거의 쓰이지 않는 단축키들이라서 그냥 리스트에 포함시키지 않았다.<br>]]>
    
    </summary>
    
      <category term="Mac" scheme="http://bestalign.github.io/tags/Mac/"/>
    
      <category term="OS X" scheme="http://bestalign.github.io/tags/OS-X/"/>
    
      <category term="bash" scheme="http://bestalign.github.io/tags/bash/"/>
    
      <category term="emacs" scheme="http://bestalign.github.io/tags/emacs/"/>
    
      <category term="shortcut" scheme="http://bestalign.github.io/tags/shortcut/"/>
    
      <category term="terminal" scheme="http://bestalign.github.io/tags/terminal/"/>
    
      <category term="단축키" scheme="http://bestalign.github.io/tags/%EB%8B%A8%EC%B6%95%ED%82%A4/"/>
    
      <category term="맥" scheme="http://bestalign.github.io/tags/%EB%A7%A5/"/>
    
      <category term="배시" scheme="http://bestalign.github.io/tags/%EB%B0%B0%EC%8B%9C/"/>
    
      <category term="이맥스" scheme="http://bestalign.github.io/tags/%EC%9D%B4%EB%A7%A5%EC%8A%A4/"/>
    
      <category term="터미널" scheme="http://bestalign.github.io/tags/%ED%84%B0%EB%AF%B8%EB%84%90/"/>
    
      <category term="번역" scheme="http://bestalign.github.io/categories/%EB%B2%88%EC%97%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 상속]]></title>
    <link href="http://bestalign.github.io/2015/08/02/JavaScript-Inheritance/"/>
    <id>http://bestalign.github.io/2015/08/02/JavaScript-Inheritance/</id>
    <published>2015-08-03T02:41:00.000Z</published>
    <updated>2015-08-26T08:48:13.000Z</updated>
    <content type="html"><![CDATA[<p>C++나 Java는 언어자체에서 상속을 위한 방법을 지원하는데 반해서 JavaScript는 이상하게도 특별히 상속을 위해 따로 지원하는 문법이 없다. 더욱이 class가 아닌 prototype을 이용해서 상속을 구현해야하기 때문에 코드가 다른 언어에 비해 길고 이해하기가 어렵다. Douglas Crockford는 이것에 관해서 JavaScript 자체가 prototype 컨셉을 완벽히 이해하고 있지 않다고 말했다 – <a href="https://youtu.be/ya4UHuXNygM?t=50m25s" target="_blank" rel="external">Crockford on JavaScript - Act III: Function the Ultimate 50분20초</a>. ECMAScript 2015(ES6)에서는 다행히 <em>class</em>와 함께 <em>extends</em> 키워드를 추가해서 쉽게 상속을 할 수 있게 되었다.</p>
<a id="more"></a>
<p>아래 코드는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript" target="_blank" rel="external">MDN Introduction to Object-Oriented JavaScript</a>의 코드가 이해하기 좋아서 가져왔다.</p>
<script src="//gist.github.com/aa5c1961616d496b476e.js?file=Inheritance.js"></script>
<h2 id="Line_18-22">Line 18-22</h2><p>Student의 생성자(constructor)를 만든다. Line 16에선 Student의 생성자 안에서 Person의 생성자를 호출한다. 이것은 Java의 super()와 같은 역할을 하는데, Person 생성자를 불러서 <code>firstname</code> property를 만들기 위해서이다 – <em>Student 생성자에서 직접 할 수도 있겠지만 그러면 상속의 의미가 없어진다.</em> super()와 한 가지 다른 건 call function을 사용해서 현재 Student 생성자의 context를 바인딩 한다는 점이다. 바인딩에 대한 내용은 나중에 다뤄보도록 하겠다.</p>
<h2 id="Line_25_-_26">Line 25 - 26</h2><p>JavaScript의 상속에서 가장 중요한 부분이다. <strong><code>Person.prototype</code>을 상속받기 위해 Student의 prototype를 업데이트한다.</strong> Person object를 만들어서 Student의 prototype으로 사용하게 되는데, 통째로 Person.prototype을 받으면서 Person의 생성자도 상속받게 되므로 다시 Student 생성자를 넣어준다.</p>
<p>코드를 보고 의문점이 두가지가 있었다.</p>
<p>그 중 하나는 새로운 Person object를 만들어서 사용한다는 것이었다. 왜냐하면 <code>Person.prototype</code>를 바로 prototype으로 사용하는게 속도 면에서 좋기 때문이다. Person object를 만들어서 사용하는 것과 <code>Person.prototype</code>을 사용해서 Student object를 만들었을때 Prototype chaining은 다음과 같다.</p>
<script src="//gist.github.com/aa5c1961616d496b476e.js?file=prototype_inheritance_prototype_chaining.txt"></script>
<p>하지만 Line 26에서 생성자를 업데이트 하는 것을 보고 바로 그 이유를 알았다. 만약 <code>Person.prototype</code>을 Student의 prototype으로 사용할 경우 Student 생성자를 업데이트 해버리면 Person의 생성자까지 같이 바뀌어버리기 때문이다. 또, Line 28-35에서 <code>Student.prototype</code>에 function을 더 추가하는데 마찬가지로 <code>Person.prototype</code>의 값을 바꿔버리게 된다.</p>
<p>두 번째 의문은 Person object를 만들 때 <code>new Person()</code>을 사용하지 않고 <strong>생성자를 호출하지 않는</strong> <code>Object.create(Person.prototype)</code>를 사용한다는 점이었다. 이건 아주 단순한 이유였는데, 각각의 Student object가 <code>firstname</code> property를 가져야하기 때문이다. <code>firstname</code> property는 Student 생성자에서 값이 정해져야 하므로 – <em>Line 18-22에서 설명했듯이 Person 생성자는 Student 생성자 내에서 호출된다</em> – Student의 prototype을 만드는 이곳에서는 <code>Object.create(Person.prototype)</code>를 사용해야만 한다.</p>
<p>다시 말해보자면 <strong>Person object를 만들었다고 생각하는 것보다 <code>Person.prototype</code>을 상속받는 prototype object를 새로 하나 만든다고 생각하는게 이해하기 더 쉽다.</strong> </p>
<h2 id="Line_28-31">Line 28-31</h2><p><code>Person.prototype</code>에서 선언 된 <code>sayHello</code> 함수를 재정의 한다. <code>Student.prototype</code>에 새로운 이름이 같은 다른 함수를 선언 하는 것 뿐이며 <code>Person.prototype</code>의 <code>sayHello</code> 함수는 Property Shadowing에 의해 가려진다.</p>
<ul>
<li>참고글: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript" target="_blank" rel="external">MDN Introduction to Object-Oriented JavaScript</a></li>
<li>참고동영상: <a href="https://youtu.be/ya4UHuXNygM?t=50m25s" target="_blank" rel="external">Crockford on JavaScript - Act III: Function the Ultimate 50분20초</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>C++나 Java는 언어자체에서 상속을 위한 방법을 지원하는데 반해서 JavaScript는 이상하게도 특별히 상속을 위해 따로 지원하는 문법이 없다. 더욱이 class가 아닌 prototype을 이용해서 상속을 구현해야하기 때문에 코드가 다른 언어에 비해 길고 이해하기가 어렵다. Douglas Crockford는 이것에 관해서 JavaScript 자체가 prototype 컨셉을 완벽히 이해하고 있지 않다고 말했다 – <a href="https://youtu.be/ya4UHuXNygM?t=50m25s">Crockford on JavaScript - Act III: Function the Ultimate 50분20초</a>. ECMAScript 2015(ES6)에서는 다행히 <em>class</em>와 함께 <em>extends</em> 키워드를 추가해서 쉽게 상속을 할 수 있게 되었다.</p>]]>
    
    </summary>
    
      <category term="Inheritance" scheme="http://bestalign.github.io/tags/Inheritance/"/>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/tags/JavaScript/"/>
    
      <category term="property shadowing" scheme="http://bestalign.github.io/tags/property-shadowing/"/>
    
      <category term="prototype chain" scheme="http://bestalign.github.io/tags/prototype-chain/"/>
    
      <category term="상속" scheme="http://bestalign.github.io/tags/%EC%83%81%EC%86%8D/"/>
    
      <category term="자바스크립트" scheme="http://bestalign.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="프로토타입 체인" scheme="http://bestalign.github.io/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8/"/>
    
      <category term="프로퍼티 쉐도잉" scheme="http://bestalign.github.io/tags/%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%89%90%EB%8F%84%EC%9E%89/"/>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Prototype Chain and Property Shadowing]]></title>
    <link href="http://bestalign.github.io/2015/07/28/Prototype-Chain/"/>
    <id>http://bestalign.github.io/2015/07/28/Prototype-Chain/</id>
    <published>2015-07-28T07:29:53.000Z</published>
    <updated>2015-08-26T08:46:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Prototype_Chain">Prototype Chain</h1><p><strong>JavaScript의 Prototype Chain은 <em>[[Prototype]]</em>으로 이루어지는 object들의 연결을 말한다.</strong> JavaScript의 Primitive Type을 제외한 모든 object는 <em>[[Prototype]]</em>을 가지고 있으며 그 연결된 Prototype Chain은 마치 Linked List 처럼 생겼다. Prototype Chain의 마지막은 항상 <code>Object.prototype</code>에서 끝나며, <code>Object.prototype</code>의 <em>[[Prototype]]</em>은 일반적인 Linked List처럼 null로 끝난다.<br><a id="more"></a></p>
<script src="//gist.github.com/99cb16fbee2e48e748c2.js?file=prototype_chain.js"></script>
<p>위의 코드는 <code>A_Prototype</code>을 만들고 거기서 A라는 instance를 생성하는 것을 보여준다. 이 object와 prototype의 Prototype Chain을 그래프로 간략히 그려보면 다음과 같다.</p>
<script src="//gist.github.com/99cb16fbee2e48e748c2.js?file=prototype_chain_example.js"></script>
<p>위의 예제에 써 있듯이 <code>A</code>, <code>A_Prototype</code>, <code>Object.prototype</code>, <code>null</code>순으로 Prototype Chain이 연결된다. <code>Object.prototype</code>에는 아주 많은 property가 있지만 가독성을 위해 생략했다. JavaScript engine은 object의 property를 접근할 때 그 object의 property 뿐만이 아니라 상황에 따라 Prototype Chain으로 연결된 상위 object의 property까지 확인하게 된다.</p>
<p>위의 예제에서 <code>A.z</code>는 <code>A</code>의 property이므로 바로 3을 출력한다. <code>A.x</code>와 <code>A.y</code>같은 경우는 <code>A</code>가 가지고 있지 않은 property이기 때문에 Prototype Chain을 거슬러 올라가면서 확인하게 되며, <code>A_Prototype</code>의 property인 <code>A_Prototype.x</code>, <code>A_Prototype.y</code>의 값인 1, 2를 출력하게 된다. <code>A.x</code>와 <code>A.y</code>는 <code>A_Prototype</code>에게서 상속받았다고 볼 수 있다.</p>
<p>마지막으로 <code>A.a</code>는 위의 Prototype Chain에 있는 어느 object에도 존재하지 않는 property이다. JavaScript engine은 Prototype Chain의 끝인 <code>Object.prototype</code>까지 확인한 뒤 <code>undefined</code>를 출력하게 된다.</p>
<h1 id="Property_Shadowing">Property Shadowing</h1><p>위의 Prototype Chain 예제에서는 <code>A</code>와 <code>A_Prototype</code> 모두 겹치지 않는 property를 가지고 있다. 만약 이들 중 이름이 겹치는 property가 존재한다면 무슨 일이 일어날까?</p>
<script src="//gist.github.com/99cb16fbee2e48e748c2.js?file=property_shadowing.js"></script>
<p>JavaScript engine은 특정 property를 찾을 때 <strong>주어진 object부터</strong> Prototype Chain을 따라 상위로 올라가면서 property를 확인하고 가장 먼저 찾은 property를 가져온다. 이런 방식으로 동작하기 때문에 상위 object에 같은 이름의 property가 존재한다고 해도 무시하게 된다. 이것을 바로 Property Shadowing이라고 부른다.</p>
<script src="//gist.github.com/99cb16fbee2e48e748c2.js?file=property_shadowing_example.js"></script>
<p>Property Shadowing에 의해서 Line 9에서는 <code>A_Prototype.x</code>의 값인 1을 상속받지 않고 <code>A.x</code>의 값인 4를 출력한다. Variable뿐만이 아니라 Function도 똑같이 object의 property가 될 수 있으므로 Prototype Chain과 Property Shadowing의 영향 하에 있다. 이를 이용해서 JavaScript에서는 <em>class</em>나 <em>extends</em> 키워드 없이 function overriding과 object inheritance를 구현한다.</p>
<ul>
<li>관련글: <a href="/2015/08/26/JavaScript-Prototype/" title="JavaScript Prototype">JavaScript Prototype</a></li>
<li>참고글: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain" target="_blank" rel="external">MDN Inheritance and the Prototype Chain</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Prototype_Chain">Prototype Chain</h1><p><strong>JavaScript의 Prototype Chain은 <em>[[Prototype]]</em>으로 이루어지는 object들의 연결을 말한다.</strong> JavaScript의 Primitive Type을 제외한 모든 object는 <em>[[Prototype]]</em>을 가지고 있으며 그 연결된 Prototype Chain은 마치 Linked List 처럼 생겼다. Prototype Chain의 마지막은 항상 <code>Object.prototype</code>에서 끝나며, <code>Object.prototype</code>의 <em>[[Prototype]]</em>은 일반적인 Linked List처럼 null로 끝난다.<br>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/tags/JavaScript/"/>
    
      <category term="property shadowing" scheme="http://bestalign.github.io/tags/property-shadowing/"/>
    
      <category term="prototype chain" scheme="http://bestalign.github.io/tags/prototype-chain/"/>
    
      <category term="자바스크립트" scheme="http://bestalign.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="프로토타입 체인" scheme="http://bestalign.github.io/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8/"/>
    
      <category term="프로퍼티 쉐도잉" scheme="http://bestalign.github.io/tags/%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%89%90%EB%8F%84%EC%9E%89/"/>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[new와 prototype]]></title>
    <link href="http://bestalign.github.io/2015/07/20/new-prototype/"/>
    <id>http://bestalign.github.io/2015/07/20/new-prototype/</id>
    <published>2015-07-20T17:33:56.000Z</published>
    <updated>2015-08-27T07:32:20.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript에서도 다른 여타 언어들처럼 instance를 생성할 떄 new를 사용한다. JavaScript는 prototype으로 instance를 생성해야 하기 때문에 Java나 C++같은 언어와는 다른 방식을 가지고 있다. 내부적으로 어떤식으로 동작하는지 궁금해서 검색해보다가 <a href="https://en.wikipedia.org/wiki/Douglas_Crockford" target="_blank" rel="external">Douglas Crockford</a>의 책 <em>JavaScript: The Good Parts</em>에 좋은 코드가 있어서 가져와보았다. 아래의 코드는 new가 keyword가 아니라 function이라고 가정했을 때 적어본 것이다.<br><a id="more"></a></p>
<script src="//gist.github.com/5111bb2e85c5b348f189.js?file=new-fuction.js"></script>
<p>object를 생성할 때 쓰인 Object.create()는 완전히 빈 object를 만들어서 거기에다가 단순히 prototype을 연결시키는 역할을 한다. 위의 line 13의 코드를 바꿔보자면 다음과 같다.</p>
<script src="//gist.github.com/5111bb2e85c5b348f189.js?file=object-create.js"></script>
<p>이렇게 만들어진 <em>new function</em>을 이용하면 아래와 같이 new를 사용하지 않고 새로운 instance를 만들 수 있다.</p>
<script src="//gist.github.com/5111bb2e85c5b348f189.js?file=point-new.js"></script>
<p>Douglas Crockford는 <em>JavaScript: The Good Parts</em>에서 new을 사용하는 것에 대해서 부정적인 입장을 보였다. 혹시나 개발자가 실수로 new를 사용하는 것을 잊어버리면 instance생성이 아닌 일반적인 function 호출이 되어버려서 생성자 내부에서 쓰이는 this가 global로 바인딩 되어버리기 때문이다. JavaScript engine는 컴파일/런타임 때 아무런 오류를 보여주지 않기 때문에 더욱 문제가 된다. 실제로 많은 사람들이 이 문제로 많은 버그를 겪었고, ECMAScript5부터 <strong>strict mode</strong>를 지원해서 바인딩없이 function이 호출될 경우 this가 undefined로 바인딩되도록 하였다.</p>
<p>다른 것보다도 class가 없는 JavaScript에 Java/C++와 같이 new를 사용하도록 만들었다는 것 자체가 문제라고 본다. prototype을 기반으로 한 훨씬 이해하기 쉬운 instance 생성 문법도 있었을텐데, Java랑 비슷한 문법으로 된 건 그 당시 Netscape의 정책 때문이라고 알고 있다. 열 흘만에 만들어진 언어의 숙명이랄까. 멀리 갈 것도 없이 나부터 바로 이해가 안돼서 이런 글을 쓰게 되었으니.. ES6부터는 아예 class keyword를 지원해서 훨씬 직관적으로 class를 선언하고 instance를 생성할 수 있게 되었다 – 당연하게도 prototype기반 언어인 것은 변함이 없다. <a href="http://www.2ality.com/" target="_blank" rel="external">Dr. Axel Rauschmayer</a>가 적은 글 중에 ES6의 class에 대한 좋은 글이 있는데 나중에 한 번 다뤄볼 생각이다.</p>
<ul>
<li>참고글:<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="external">MDN - JavaScript Object.create()</a></li>
<li><a href="http://stackoverflow.com/questions/7962886/how-does-object-create-work-in-javascript" target="_blank" rel="external">StackOverflow - How does Object.create work in JavaScript</a></li>
</ul>
</li>
<li>관련글: <a href="/2015/08/26/JavaScript-Prototype/" title="JavaScript Prototype">JavaScript Prototype</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript에서도 다른 여타 언어들처럼 instance를 생성할 떄 new를 사용한다. JavaScript는 prototype으로 instance를 생성해야 하기 때문에 Java나 C++같은 언어와는 다른 방식을 가지고 있다. 내부적으로 어떤식으로 동작하는지 궁금해서 검색해보다가 <a href="https://en.wikipedia.org/wiki/Douglas_Crockford">Douglas Crockford</a>의 책 <em>JavaScript: The Good Parts</em>에 좋은 코드가 있어서 가져와보았다. 아래의 코드는 new가 keyword가 아니라 function이라고 가정했을 때 적어본 것이다.<br>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/tags/JavaScript/"/>
    
      <category term="new" scheme="http://bestalign.github.io/tags/new/"/>
    
      <category term="prototype" scheme="http://bestalign.github.io/tags/prototype/"/>
    
      <category term="자바스크립트" scheme="http://bestalign.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="프로토타입" scheme="http://bestalign.github.io/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/"/>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Lexical Scope and Dynamic Scope]]></title>
    <link href="http://bestalign.github.io/2015/07/12/Lexical-Scope-and-Dynamic-Scope/"/>
    <id>http://bestalign.github.io/2015/07/12/Lexical-Scope-and-Dynamic-Scope/</id>
    <published>2015-07-13T03:33:56.000Z</published>
    <updated>2015-08-27T08:49:20.000Z</updated>
    <content type="html"><![CDATA[<p>C/C++, Java, 그리고 JavaScript 같이 우리가 접하는 대부분의 언어들은 Lexical Scope를 사용한다. Lexical Scope는 Static Scope라고도 불린다. 반대의 방식으로는 Dynamic Scope가 있으며 Perl, Bash Shell, APL 같은 몇몇 오래된 언어들이 사용하는 방식이다. 두 방식의 정의는 다음과 같다.</p>
<blockquote>
<p><strong>Lexical scope</strong>: use environment where function [and variable] is defined<br><strong>Dynamic scope</strong>: use environment where function [and variable] is called</p>
</blockquote>
<p>출처: <a href="https://courses.cs.washington.edu/courses/cse341/14sp/slides/lec09.pdf" target="_blank" rel="external">University of Washington CSE341 2014 Spring - Lecture 9</a></p>
<a id="more"></a> 
<p>Lexical Scope는 변수나 함수가 <strong>정의 된 곳</strong>의 context를 사용하며, Dynamic Scope는 변수나 함수가 <strong>불려진 곳</strong>의 context를 사용한다. Lexical Scope는 아주 익숙한 개념이므로 Dynamic Scope에 대해서만 간단히 설명하고, Lexical Scope가 JavaScript에서 어떻게 쓰이는 지 적어볼까 한다.</p>
<h2 id="Dynamic_Scope">Dynamic Scope</h2><script src="//gist.github.com/a6e917597435ef5734f9.js?file=javascript_dynamic_scope.js"></script>
<p>위의 코드는 JavaScript에 Dynamic Scope가 적용되었다고 가정했다. – <em>실제로 실행할 경우 다른 결과값이 나온다</em>. 모든 결과값은 Line 3의 <strong>x의 값을 읽은 타이밍</strong>에 따라서 – 이름 그대로 동적으로 – 달라진다. Line 12에서 처음으로 <em>foo function</em>이 호출될 때 x의 값은 10이므로 당연히 결과값은 10이 출력된다. Line 13에서도 x의 값은 10이지만 <em>bar function</em>내에서 x를 15으로 재선언 뒤 <em>foo function</em>을 호출하기 때문에 결과값이 15로 바뀌게 된다.</p>
<h1 id="언어에_따른_Lexical_Scope의_차이">언어에 따른 Lexical Scope의 차이</h1><h2 id="Block_Scope">Block Scope</h2><p>C계열의 언어들은 모든 block이 자신의 scope를 가진다.</p>
<script src="//gist.github.com/a6e917597435ef5734f9.js?file=block_scope.c"></script>
<p>if block 자체가 자신의 scope를 가지고 있으므로 <strong>main function의 scope</strong>에는 영향없이 따로 x의 값을 가질 수 있다. if block이 지난 뒤에는 다시 <strong>main function의 scope</strong>에 접근하게 된다.</p>
<h2 id="Function_Scope">Function Scope</h2><p>JavaScript는 Function Scope를 사용한다. function만이 자신의 scope를 가진다.</p>
<script src="//gist.github.com/a6e917597435ef5734f9.js?file=function_scope_if_block.js"></script>
<p>Block Scope와 JavaScript에서는 <strong>function만이 scope를 가지기 때문에</strong> if block 안에서 x값을 수정하면 <strong>foo function의 scope</strong>의 x에 값이 바뀌게 된다 – <em>실제 JavaScript의 if block 안에서 var를 다시 선언하는 건 좋은 코딩스타일은 아니다</em>. 그러므로, if block이 끝난 뒤에도 수정된 값을 가지게 된다.</p>
<h1 id="그럼_JavaScript에서_새_Scope_생성은?">그럼 JavaScript에서 새 Scope 생성은?</h1><p>당연한 이야기지만 Function Scope를 생성해야 하므로 필요한 곳에 function을 추가하면 된다.</p>
<script src="//gist.github.com/a6e917597435ef5734f9.js?file=function_scope_iife.js"></script>
<p>예제와 같은 경우는 if block의 한정된 곳에서 한번만 실행 될 코드이므로 Immediately-Invoked Function Expression(IIFE)를 추가한다. IIFE는 만들어지자마자 바로 실행되며 동시에 새로운 scope를 가진다. 독립적인 scope를 가지므로 그 안에서 선언된 x는 <strong>foo function의 scope</strong>에 영향을 미치지 않는다.</p>
<p>JavaScript에서 function을 이용한 Lexical Scope는 Closure를 이해하는데 아주 중요한 요소 중 하나이며 그 외에도 모듈화를 하는데도 빈번히 사용된다.</p>
<h1 id="Let_keyword_in_ES6">Let keyword in ES6</h1><p>이번에 제정된 ES6(ECMAScript 2015)에서는 let keyword가 새로 추가되었다. var과 비슷하게 변수를 선언하는 keyword이지만 많은 부분에서 차이를 보인다.</p>
<ul>
<li>var keyword<ul>
<li>Function Scope</li>
<li>Hoisting</li>
<li>중복선언 가능</li>
</ul>
</li>
<li>let keyword<ul>
<li>Block Scope</li>
<li>NO Hoisting</li>
<li>중복선언 불가 (에러 발생)</li>
</ul>
</li>
</ul>
<p>참고글:</p>
<ul>
<li><a href="https://courses.cs.washington.edu/courses/cse341/14sp/" target="_blank" rel="external">University of Washington CSE341 2014 Spring</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="external">MDN JavaScript let</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>C/C++, Java, 그리고 JavaScript 같이 우리가 접하는 대부분의 언어들은 Lexical Scope를 사용한다. Lexical Scope는 Static Scope라고도 불린다. 반대의 방식으로는 Dynamic Scope가 있으며 Perl, Bash Shell, APL 같은 몇몇 오래된 언어들이 사용하는 방식이다. 두 방식의 정의는 다음과 같다.</p>
<blockquote>
<p><strong>Lexical scope</strong>: use environment where function [and variable] is defined<br><strong>Dynamic scope</strong>: use environment where function [and variable] is called</p>
</blockquote>
<p>출처: <a href="https://courses.cs.washington.edu/courses/cse341/14sp/slides/lec09.pdf">University of Washington CSE341 2014 Spring - Lecture 9</a></p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/tags/JavaScript/"/>
    
      <category term="lexical" scheme="http://bestalign.github.io/tags/lexical/"/>
    
      <category term="lexical scope" scheme="http://bestalign.github.io/tags/lexical-scope/"/>
    
      <category term="scope" scheme="http://bestalign.github.io/tags/scope/"/>
    
      <category term="렉시컬" scheme="http://bestalign.github.io/tags/%EB%A0%89%EC%8B%9C%EC%BB%AC/"/>
    
      <category term="렉시컬 스코프" scheme="http://bestalign.github.io/tags/%EB%A0%89%EC%8B%9C%EC%BB%AC-%EC%8A%A4%EC%BD%94%ED%94%84/"/>
    
      <category term="스코프" scheme="http://bestalign.github.io/tags/%EC%8A%A4%EC%BD%94%ED%94%84/"/>
    
      <category term="자바스크립트" scheme="http://bestalign.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript Prototype]]></title>
    <link href="http://bestalign.github.io/2015/07/07/JavaScript-Prototype/"/>
    <id>http://bestalign.github.io/2015/07/07/JavaScript-Prototype/</id>
    <published>2015-07-07T09:27:32.000Z</published>
    <updated>2015-08-26T08:43:08.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript의 prototype를 처음부터 다시 공부하면서 적어보았다. C/C++와 Java로 프로그래밍을 시작했고 오래써왔기 때문에 prototype을 이해하는데 꽤 오랜시간이 걸렸다. 둘 다 상속, 캡슐화, 추상화, 다형성 등을 전부 지원하지만 접근하는 방식은 좀 다를 뿐 깊게 들어가보면 동작하는 방식은 대동소이하다. Java와 비교하면서 적었기 때문에 Java를 쓰시는 분이면 이해하기 쉬울 듯하다.<br><a id="more"></a></p>
<h1 id="Java_Class와_JavaScript_Prototype">Java Class와 JavaScript Prototype</h1><h2 id="Java_Class">Java Class</h2><script src="//gist.github.com/6e1969ee79b189bef332.js?file=JavaClassDeclaration.java"></script>
<p>Java는 class를 <strong>설계도</strong>삼아 object를 만들어낸다. 위의 코드에서는 Point class instance인 <em>p1</em>, <em>p2</em>가 생성된다. 메모리 관점에서 봤을 때 완전히 똑같은 object 두 개가 따로 메모리 상에 저장된다.</p>
<h2 id="JavaScript_Prototype">JavaScript Prototype</h2><script src="//gist.github.com/6e1969ee79b189bef332.js?file=javascript_prototype_declaration.js"></script>
<p>JavaScript 코드는 Java 코드와 비교하면서 한 줄 한 줄 설명해 해보았다.</p>
<h3 id="Line_2_~_5">Line 2 ~ 5</h3><p>Java에서 <em>class</em>키워드를 사용해서 class를 선언하는데 비해서, JavaScript에서는 먼저 생성자(constructor)를 만든다. <em>Point function</em>이 선언됨과 동시에 <strong>Point function object</strong>가 생성된다 – <em>JavaScript에서는 function도 object로 관리된다.</em> <strong>Point function object</strong>의 내부에는 <em>prototype</em>이라는 property가 자동적으로 생성된다. 이게 바로 Point의 prototype이다. prototype은 메모리 상에 존재하는 <strong>object</strong>이며 거기서 생성/파생되는 모든 object의 <strong>원형</strong>이 된다. 기본으로 만들어 지는 prototype은 아무런 값이 없는 object이다 – 보든 JavaScript의 Object가 그렇듯 prototype object도 <em>Object.prototype</em>을 기반으로 한 object이다.</p>
<p><strong>생성자</strong>인 <em>Point function</em> 에서는 일반적으로 property를 만들고 초기화하는 일을 한다. Java에서는 x, y field<sup>1</sup> 를 class 내에 따로 선언하지만 JavaScript는 따로 property<sup>1</sup> 선언은 하지 않고 <strong>생성자</strong> 내에서 <code>this.x = x</code>처럼 값을 넣어서 선언 및 초기화 한다. <strong>생성자에서 추가 된 property는 prototype과는 상관없이 각 object에 종속된다.</strong></p>
<h3 id="Line_8_~_10">Line 8 ~ 10</h3><p><em>print method</em>를 Point의 prototype에 추가한다. 이것은 Java의 print method와 같은 역할을 하게 된다. <strong>prototype에 추가 된 method와 property는 이후에 생성된 모든 instance에서 접근이 가능하다.</strong></p>
<h3 id="Line_14_~_15">Line 14 ~ 15</h3><p>Line 14-15에서는 <em>new</em>키워드로 Point instance <em>p1</em>, <em>p2</em>를 생성한다. 내부적으로 동작하는 걸 자세히 따져보면 C/C++나 Java같은 instance화 라기보다는 <strong>prototype을 가리키는 빈 object를 만드는 것에 가깝다.</strong></p>
<p><em>p1</em>과 <em>p2</em>는 아주 단순한 구조를 가지고 있다. 빈 object에 x, y property를 가지고 있고, 거기에 추가로 숨겨진 property인 <em>[[Prototype]]</em>를 가진다 – Chrome, Safari 등 많은 모던브라우저에서는 <em>__proto__</em>라는 이름을 사용하고 있지만 ECMAScript 표준은 <em>[[Prototype]]</em>이다. </p>
<p>두 instance의 <em>[[Prototype]]</em>은 모두 <em>Person.prototype</em>를 가리킨다. 간단히 말해, <strong><em>p1</em>과 <em>p2</em>는 하나의 prototype object를 공유한다.</strong> 이렇게 prototype object를 공유함으로써 Prototype Chain과 Property Shadowing이 가능해진다.</p>
<svg width="320" height="320" xmlns="http://www.w3.org/2000/svg"><defs><marker refy="50" refx="50" markerheight="5" markerwidth="5" viewbox="0 0 100 100" se_type="rightarrow" orient="auto" markerunits="strokeWidth" id="se_marker_end_svg_6"><path stroke-width="10" stroke="#000000" fill="#000000" d="m100,50l-100,40l30,-40l-30,-40z"/></marker><marker refy="50" refx="50" markerheight="5" markerwidth="5" viewbox="0 0 100 100" se_type="rightarrow" orient="auto" markerunits="strokeWidth" id="se_marker_end_svg_11"><path stroke-width="10" stroke="#000000" fill="#000000" d="m100,50l-100,40l30,-40l-30,-40z"/></marker></defs><g><title>JavaScript prototype</title><rect id="svg_2" height="80" width="160" y="40" x="80" stroke-width="2" stroke="#000000" fill="none"/><text xml:space="preserve" text-anchor="middle" font-family="Nanum Gothic" font-size="20" id="svg_3" y="60" x="160" stroke-linecap="null" stroke-linejoin="null" stroke-width="0" stroke="#000000" fill="#000000">Point.prototype</text><rect id="svg_4" height="80" width="130" y="200" x="10" stroke-linecap="null" stroke-linejoin="null" stroke-width="2" stroke="#000000" fill="none"/><rect id="svg_5" height="80" width="130" y="200" x="180" stroke-linecap="null" stroke-linejoin="null" stroke-width="2" stroke="#000000" fill="none"/><line y="NaN" x="NaN" marker-end="url(#se_marker_end_svg_6)" id="svg_6" y2="130" x2="140" y1="200" x1="80" stroke-linecap="null" stroke-linejoin="null" stroke-width="2" stroke="#000000" fill="none"/><text xml:space="preserve" text-anchor="middle" font-family="Nanum Gothic" font-size="20" id="svg_9" y="220" x="80" stroke-linecap="null" stroke-linejoin="null" stroke-width="0" stroke="#000000" fill="#000000">p1</text><text xml:space="preserve" text-anchor="middle" font-family="Nanum Gothic" font-size="20" id="svg_10" y="220" x="250" stroke-linecap="null" stroke-linejoin="null" stroke-width="0" stroke="#000000" fill="#000000">p2</text><line marker-end="url(#se_marker_end_svg_11)" id="svg_11" y2="130" x2="180" y1="200" x1="230" stroke-linecap="null" stroke-linejoin="null" stroke-width="2" stroke="#000000" fill="none"/><text xml:space="preserve" text-anchor="middle" font-family="Nanum Gothic" font-size="20" id="svg_12" y="260" x="70" stroke-linecap="null" stroke-linejoin="null" stroke-width="0" stroke="#000000" fill="#000000">x:0, y:0</text><text id="svg_13" xml:space="preserve" text-anchor="middle" font-family="Nanum Gothic" font-size="20" y="260" x="240" stroke-linecap="null" stroke-linejoin="null" stroke-width="0" stroke="#000000" fill="#000000">x:5, y:5</text><text xml:space="preserve" text-anchor="middle" font-family="Nanum Gothic" font-size="20" id="svg_14" y="90" x="160" stroke-linecap="null" stroke-linejoin="null" stroke-width="0" stroke="#000000" fill="#000000">print function</text></g></svg>

<ul>
<li>관련글<ul>
<li><a href="/2015/07/20/new-prototype/" title="New와 Prototype">New와 Prototype</a></li>
<li><a href="/2015/07/28/Prototype-Chain/" title="Prototype Chain">Prototype Chain</a>
</li>
</ul>
</li>
</ul>
<hr>
<p>[1]: Java에서는 field, JavaScript에서는 property</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript의 prototype를 처음부터 다시 공부하면서 적어보았다. C/C++와 Java로 프로그래밍을 시작했고 오래써왔기 때문에 prototype을 이해하는데 꽤 오랜시간이 걸렸다. 둘 다 상속, 캡슐화, 추상화, 다형성 등을 전부 지원하지만 접근하는 방식은 좀 다를 뿐 깊게 들어가보면 동작하는 방식은 대동소이하다. Java와 비교하면서 적었기 때문에 Java를 쓰시는 분이면 이해하기 쉬울 듯하다.<br>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/tags/JavaScript/"/>
    
      <category term="class" scheme="http://bestalign.github.io/tags/class/"/>
    
      <category term="instance" scheme="http://bestalign.github.io/tags/instance/"/>
    
      <category term="object" scheme="http://bestalign.github.io/tags/object/"/>
    
      <category term="prototype" scheme="http://bestalign.github.io/tags/prototype/"/>
    
      <category term="객체" scheme="http://bestalign.github.io/tags/%EA%B0%9D%EC%B2%B4/"/>
    
      <category term="오브젝트" scheme="http://bestalign.github.io/tags/%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8/"/>
    
      <category term="인스턴스" scheme="http://bestalign.github.io/tags/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4/"/>
    
      <category term="자바스크립트" scheme="http://bestalign.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="클래스" scheme="http://bestalign.github.io/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"/>
    
      <category term="프로토타입" scheme="http://bestalign.github.io/tags/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/"/>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript Data Types]]></title>
    <link href="http://bestalign.github.io/2015/06/29/JavaScript-Data-Type/"/>
    <id>http://bestalign.github.io/2015/06/29/JavaScript-Data-Type/</id>
    <published>2015-06-29T08:20:21.000Z</published>
    <updated>2015-08-27T09:26:47.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript data type은 다음과 같다. 5개의 primitive type – 얼마전에 새로 나온 <em>ECMAScript 2015</em>의 스펙에서는 symbol type이 추가 – 그리고 하나의 object type있다. primitive type은 가장 기본적이고 단순한 값을 가지며 들어가는 모든 값들은 immutable이다.</p>
<ul>
<li>primitive type<ul>
<li>undefined type</li>
<li>null type</li>
<li>boolean type</li>
<li>number type</li>
<li>string type</li>
</ul>
</li>
<li>object type</li>
</ul>
<a id="more"></a> 
<h2 id="undefined_type">undefined type</h2><p>undefined type은 단 하나의 값 <em>undefined</em>을 가지고 있다. type 이름과 거기에 들어가는 값의 이름이 같다.</p>
<p><em>undefined</em>는 새로 선언된 variable의 기본값으로 들어간다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// undefined의 type은 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="comment">// x의 안에 들어있는 값이 undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="null_type">null type</h2><p>undefined type 처럼, null type은 단 하나의 값 <em>null</em>을 가지고 있다. 타입 이름과 거기에 들어가는 값의 이름이 같다.</p>
<p>하지만 실제로 브라우저에서 <em>null</em>의 type을 확인해보면 <code>&quot;object&quot;</code>라고 출력된다. 이것은 JavaScript 엔진 초기버전의 버그였는데 하위 호환성을 위해서 고쳐지지 못했다. 아마 영원히 고쳐질일은 없을 듯 하다.. 자세한 내용을 알고 싶으면 <a href="http://www.2ality.com/2013/10/typeof-null.html" target="_blank" rel="external">이 링크(영문)</a>에 자세한 설명이 있다.</p>
<p><em>null</em>은 빈 값이라는 것을 의도적으로 보이기 위해 넣는 값이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">// object - 버그!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = <span class="literal">null</span>; <span class="comment">// no data</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="literal">null</span>; <span class="comment">// no object</span></span><br></pre></td></tr></table></figure>
<h2 id="boolean_type">boolean type</h2><p><em>true</em>/<em>false</em>의 type.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">// boolean</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">false</span>); <span class="comment">// boolean</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> &lt; <span class="number">2</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> == <span class="number">2</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="number_type">number type</h2><p>정수, 실수, +/- <em>Infinity</em>, <em>NaN</em>(not-a-number)이 모두 number type이다. JavaScript는 C/C++나 Java와 달리 단 하나의 숫자 type을 가지고 있다.</p>
<p>JavaScript는 숫자를 표현하기 위해서 <a href="http://en.wikipedia.org/wiki/Double_precision_floating-point_format" target="_blank" rel="external">IEEE 754 standard</a>를 사용하고 있다. 정수형/실수형을 위해 개별적인 방식은 제공되지 않고 모두 한가지 방식으로 표현된다. 숫자하나당 8 byte로 정수를 저장하기에 조금 비효율적이긴 하지만 개발할 때는 타입을 신경안써도 되기때문에 편하다는 장점이 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">1</span>); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">0.3</span>); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">Infinity</span>); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> -<span class="literal">Infinity</span>); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">NaN</span>); <span class="comment">// number</span></span><br></pre></td></tr></table></figure>
<h2 id="string_type">string type</h2><p>모든 문자열의 type.</p>
<p>JavaScript의 문자열은 Java와 같이 immutable로 일단 생성되면 값을 바꿀 수 없다. 대신 그 문자열에서 새로운 문자열을 만들어 낼 수는 있다. 내부적으로 16-bit unsigned integer set으로 저장된다.</p>
<p>String literal을 만들때는 큰따옴표 혹은 작은따옴표로 원하는 문자열을 감싸서 만들 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">"hello world!"</span>); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'hello world!'</span>); <span class="comment">// string</span></span><br></pre></td></tr></table></figure>
<h2 id="object_type">object type</h2><p>모든 객체의 type. <del>또한 null의 type.</del></p>
<p>JavaScript에는 기본적으로 탑재된 객체가 아주 많다. 모든 JavaScript 객체들의 조상인 <em>Object</em>부터 <em>Array</em>, <em>Date</em>, <em>RegExp</em>, <em>Function</em>, 그리고 Primitive type의 wrapper인 <em>Booean</em>, <em>Number</em>, <em>String</em> 까지 모두 object type이다.</p>
<p>object에 관련해서는 너무나 많은 내용이 있기 때문에 따로 글을 써볼 생각이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>
<p>참조글: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures" target="_blank" rel="external">MDN JavaScript data types and data structures</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript data type은 다음과 같다. 5개의 primitive type – 얼마전에 새로 나온 <em>ECMAScript 2015</em>의 스펙에서는 symbol type이 추가 – 그리고 하나의 object type있다. primitive type은 가장 기본적이고 단순한 값을 가지며 들어가는 모든 값들은 immutable이다.</p>
<ul>
<li>primitive type<ul>
<li>undefined type</li>
<li>null type</li>
<li>boolean type</li>
<li>number type</li>
<li>string type</li>
</ul>
</li>
<li>object type</li>
</ul>]]>
    
    </summary>
    
      <category term="Data Type" scheme="http://bestalign.github.io/tags/Data-Type/"/>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/tags/JavaScript/"/>
    
      <category term="Primitive" scheme="http://bestalign.github.io/tags/Primitive/"/>
    
      <category term="데이터 타입" scheme="http://bestalign.github.io/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85/"/>
    
      <category term="자바스크립트" scheme="http://bestalign.github.io/tags/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8/"/>
    
      <category term="JavaScript" scheme="http://bestalign.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Github pages로 블로그를 열었습니다]]></title>
    <link href="http://bestalign.github.io/2015/06/25/hello-world/"/>
    <id>http://bestalign.github.io/2015/06/25/hello-world/</id>
    <published>2015-06-26T03:33:56.000Z</published>
    <updated>2015-08-26T09:11:47.000Z</updated>
    <content type="html"><![CDATA[<p>보통 공부하는 내용들을 따로 정리하거나 하는 편은 아닌데 기록으로 남기고 공유해보고 싶다는 생각이 들어서 만들어보게 되었습니다. 일반적으로 Github Pages를 만들 때 Jekyll을 많이 쓰는데 저는 단지 요즘 JavaScript에 꽂혀있는 관계로 Node.js 기반인 Hexo를 이용해서 블로그를 만들어 보았습니다. Jekyll은 Ruby기반인데 별로 써본적이 없어서 불편하기도 하구요.</p>
<p>기본 셋업에 Hexo 사이트에 올라와 있는 Theme을 적용해서 좀 밋밋합니다. 계속 조금씩 업데이트해서 부족하나마 개성을 줘 볼 생각입니다. 바닥부터 새로 만들어 볼까도 생각해봤는데 그러기엔 시간이 너무 걸릴 것 같네요.</p>
<p>아마 블로깅의 대부분은 개발에 대한 내용이 되지 않을까 싶습니다. JavaScript, Java, CSS 등등 – 특히나 프론트엔드 – 일하면서 새로 배우는 내용이라던가 개발관련 번역이라던가 이것저것 생각하고 있습니다.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>보통 공부하는 내용들을 따로 정리하거나 하는 편은 아닌데 기록으로 남기고 공유해보고 싶다는 생각이 들어서 만들어보게 되었습니다. 일반적으로 Github Pages를 만들 때 Jekyll을 많이 쓰는데 저는 단지 요즘 JavaScript에 꽂혀있는]]>
    </summary>
    
      <category term="잡담" scheme="http://bestalign.github.io/categories/%EC%9E%A1%EB%8B%B4/"/>
    
  </entry>
  
</feed>
