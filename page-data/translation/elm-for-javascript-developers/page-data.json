{"componentChunkName":"component---src-templates-blog-post-js","path":"/translation/elm-for-javascript-developers/","result":{"data":{"site":{"siteMetadata":{"title":"bestalign's dev blog","categories":[{"displayText":"홈","priority":0,"name":"home","url":"/"},{"displayText":"TIL","priority":1,"name":"til","url":"/til"},{"displayText":"개발","priority":2,"name":"dev","url":"/dev"},{"displayText":"독서","priority":3,"name":"reading","url":"/reading"},{"displayText":"번역","priority":4,"name":"translation","url":"/translation"},{"displayText":"일기","priority":5,"name":"everydaylife","url":"/everydaylife"}]}},"markdownRemark":{"id":"3303e207-a0ea-5530-b1ff-1822c9d586b9","excerpt":"이 글은 JavaScript Playground의 Elm for JavaScript Developers를 번역한 것이다. 저자인 Jack Franklin의 허락을 받고 번역하였다. GitHub에나 Twitter에서 나를 follow하고 있는 사람들은 내가 최근에 Elm…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 280px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/485ea6bbc67b5b4da4094fc876dd19e8/908b1/elm-logo.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAADHElEQVQ4y5XUyU8TYRgG8Fc9eNPE5R/wYDQB6XIAyxLUxJtxRdpO2mkLelAUNdBitTO1JEBCYgwuCcbExEQUOsAEhoTGgwuR2M1+LR1ALoLBG1g3iFTsZ75ppw60Ih6ezGSS+eV5v7wzcL5Tr3GLxUFXpBQzSJdkkI5cU4r8YlApdsdUHmP/h+O0EMDpBJdpIUiuqUzIPYZqkzNY16lXu8XiMPN3NEVQT3xPk5GfOZV+OT8Kxho7rjY5w3WdepWEvpXQpXSzbJYZpPvJoDLcPLa7keqfPUkLIZzBVqBgsDmShtoMel9CQ2R8V7QUu5BuVcizMszG97ImIWSlBX8OSkBMUGMGPffAoG6bUlta/cUXWaSzNkdKzngyaY6U1LJIZ2sJ6Rw4AZtP9yWOZkbPogRMZVEyPn0Vte28vBX3QvvCU4gudcOzH93wgoTcL3ZDBD+GWw9HNAXu8V1G84BIKc9UBlegVTbnWH+Huvw7D1Nz3Eb8qRekzPVuwF84mA0Mby93RstHWVSGPfHdDUZ+ukpG5ZFXoFSNHR8zM4FHLWX7FnkIzXs3SOA3L4ijvh1F9rGKFyzan9kICbVT/EyVPDLOjzbiE2ZXqKt1f+ECD+KXHngfGN5W6IhVvHJnMXlPCbrHYej7eEwJ5m163MKM9bFFxROvQeuIVgYVGFbs67K0p1FV+5qgoaYJU5Yr04cbBQ0dv1t4A2knydrkA1mkw/ZY5U1YCzPQDZPG67cLrb5wgB5AYv2Iu8Ad1b5l/qDSyOQ8L4kHruEuOAJrYZTrtpr2oVf0YADTQ35sGoyF6kdYlTuqjWTQJXIE9eJBJ34CJxIcYFgXJgST6SjQmDZM0Avjh+wy9kkB5mAWH3qpwOSvIWkhTQfi/sbXFyuux4vOfu3ZZPvMAU6kswy5WAdpthpT/qKSFqlpBNXfw1sWOAjMc5sI9kMeWcbe/QPLQamhSIzjzepFDsLz3EaCJuE/muVtWi2MB7w8rVrkIEJQMNANE5SrQ7MOLC9qFd5gvSAGvTwtNQWKuaO1+NDzdWJ50FDSKvixfkj0e3mL5jd7tMSnTNF1KAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"elm logo\"\n        title=\"elm logo\"\n        src=\"/static/485ea6bbc67b5b4da4094fc876dd19e8/908b1/elm-logo.png\"\n        srcset=\"/static/485ea6bbc67b5b4da4094fc876dd19e8/c26ae/elm-logo.png 158w,\n/static/485ea6bbc67b5b4da4094fc876dd19e8/908b1/elm-logo.png 280w\"\n        sizes=\"(max-width: 280px) 100vw, 280px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>이 글은 JavaScript Playground의 <a href=\"http://javascriptplayground.com/blog/2015/11/elm-for-javascript-developers/\">Elm for JavaScript Developers</a>를 번역한 것이다. 저자인 <a href=\"https://twitter.com/Jack_Franklin\">Jack Franklin</a>의 허락을 받고 번역하였다.</p>\n<hr>\n<p>GitHub에나 Twitter에서 나를 follow하고 있는 사람들은 내가 최근에 <a href=\"http://www.elm-lang.org\">Elm</a>으로 이런저런 일을 했다는 걸 알고 있을 것이다. Elm은 새로운 언어로 탄탄하고 복잡한 애플리케이션의 더욱 쉬운 개발을 목표로 한다. JavaScript로 컴파일되지만  JavaScript와 언어적으로 동일한 부분은 거의 없으며, Haskell로 개발해 본 적이 있는 사람은 Elm의 문법이 익숙할 것이다. Elm에 관한 처음 글로써, Elm의 특징과 왜 Elm을 사용해야 하는지에 대해 이야기해 볼 것이다. 상당히 다른 문법 때문에 망설여질 수도 있겠지만 일단 익숙해지면 아주 만족하게 될 것이다.</p>\n<h2 id=\"불변성immutability과-순수-함수pure-function\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EB%B3%80%EC%84%B1immutability%EA%B3%BC-%EC%88%9C%EC%88%98-%ED%95%A8%EC%88%98pure-function\" aria-label=\"불변성immutability과 순수 함수pure function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불변성(Immutability)과 순수 함수(Pure Function)</h2>\n<p>Elm 애플리케이션 내의 모든 데이터는 불변(immutable)이다. 다시 말해, 데이터의 수정이 불가능하고 생성 시에 정해진 값을 끝까지 가지고 있다. 데이터의 값이 변하지 않기 때문에 실제로 코드를 볼 때 읽고 이해하기가 훨씬 쉽다. 예를 들어 다음의 JavaScript 코드를 보자:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">var</span> person <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> name<span class=\"token operator\">:</span> <span class=\"token string\">'Jack'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">doSomethingWith</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>코드를 실행하지 않고 <code class=\"language-text\">doSomethingWith</code>가 실행 된 이후에 <code class=\"language-text\">person</code>이 가질 값을 확신할 수 있을까?</p>\n<p>없다.</p>\n<p>JavaScript의 객체는 변할 수 있으므로 <code class=\"language-text\">person</code>의 값은 어떤 식으로든 바뀔 수 있다.</p>\n<p>이것이 큰 애플리케이션에서 많은 버그가 생겨나는 원인이다. 변수들의 값을 바꿔서 애플리케이션의 상태를 수정하는 함수는 부수효과(side effect)를 가진다. 이런 함수들은 디버깅하기가 어렵다. 또한, 테스트도 힘들기 때문에 가능하다면 사용하지 않는 것이 좋다.</p>\n<p>Elm의 모든 함수는 <strong>순수(pure)</strong>하다. 이것은 다음의 두 가지 뜻을 가지고 있다:</p>\n<ul>\n<li>X라는 입력값을 받았을 때, 항상 출력값 Y를 돌려준다. 같은 값을 함수에 넣으면 항상 같은 결과를 만들어낸다.</li>\n<li>부수효과를 가지고 있지 않으며, 어떤 값도 바꾸지 않는다.</li>\n</ul>\n<p>JavaScript에서도 이런 함수들을 만드는 것은 가능하고, 애플리케이션 내에서 순수 함수만을 사용하도록 하는 규칙을 정할 수 있다. Elm은 불변성을 위해 이것을 강제하므로, 직접 짠 코드든 3rd party 라이브러리든 비순수 함수를 코드에 넣는 것이 아예 불가능하다.</p>\n<p>값을 변경할 수 없는데 어떻게 애플리케이션의 상태를 저장할지 의아해할지도 모르겠다. Elm에서는 Signal이라는 것을 사용해서 이 문제를 해결한다. 나중 글에서 다루어 볼 것이다.</p>\n<h2 id=\"타입types\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85types\" aria-label=\"타입types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입(Types)</h2>\n<p>Elm은 정적(static) 타입 언어이다. 별로 재미없게 들릴 수도 있겠지만 사실 이것이 더욱 탄탄한 애플리케이션을 개발할 수 있게 해준다. Elm에서는 모든 값이 타입을 가진다.</p>\n<div class=\"gatsby-highlight\" data-language=\"elm\"><pre class=\"language-elm\"><code class=\"language-elm\"><span class=\"token string\">\"Hello World\"</span> <span class=\"token operator\">-</span> <span class=\"token constant\">String</span> <span class=\"token keyword\">type</span>\n<span class=\"token constant\">True</span> <span class=\"token operator\">-</span> <span class=\"token constant\">Boolean</span> <span class=\"token keyword\">type</span>\n<span class=\"token number\">3</span> <span class=\"token operator\">-</span> <span class=\"token hvariable\">number</span> <span class=\"token keyword\">type</span>\n<span class=\"token number\">3.14</span> <span class=\"token operator\">-</span> <span class=\"token constant\">Float</span> <span class=\"token keyword\">type</span>\n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-</span> <span class=\"token constant\">List</span> <span class=\"token hvariable\">number</span> <span class=\"token keyword\">type</span></code></pre></div>\n<p>JavaScript와 비슷하다고 생각한다면, 대략 맞다. JavaScript(또한, 다른 대부분 언어)에서 값은 특정 타입을 가진다. 중요한 차이점은 이 타입 시스템과 함수를 합칠 때 나온다. JavaScript에서는 다양한 타입을 입력값으로 받고 다양한 타입을 돌려주는 함수를 만들 수 있다:</p>\n<div class=\"gatsby-highlight\" data-language=\"elm\"><pre class=\"language-elm\"><code class=\"language-elm\"><span class=\"token hvariable\">someMadeUpFn</span><span class=\"token punctuation\">(</span>'<span class=\"token constant\">Foo</span>'<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token number\">5</span>\n<span class=\"token hvariable\">someMadeUpFn</span><span class=\"token punctuation\">(</span><span class=\"token number\">5</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> '<span class=\"token constant\">Foo</span>'\n<span class=\"token hvariable\">someMadeUpFn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token hvariable\">name</span><span class=\"token operator\">:</span> '<span class=\"token constant\">Jack</span>' <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span> <span class=\"token hvariable\">name</span><span class=\"token operator\">:</span> '<span class=\"token hvariable\">jack</span>' <span class=\"token punctuation\">}</span></code></pre></div>\n<p>또한, JavaScript의 타입 시스템은 <strong>동적(dynamic)</strong>이다. 다시 말해서, <strong>런타임</strong> 때 타입이 결정된다. Elm의 타입 시스템은 <strong>정적(static)</strong>이며 컴파일러가 코드 실행 전에 모든 타입을 확인할 수 있다. 나중에 이것에 대해 다시 이야기해 볼 것이다.</p>\n<p>위의 코드에서는 <code class=\"language-text\">someMadeUpFn</code>이 받는 입력값에 대한 타입 제한이 없고, 무슨 타입을 돌려줘야 하는지에 대한 제한 또한 없다. Elm에서는 이것을 명시적으로 선언해줘야만 한다 (사실 컴파일러가 알아서 유추하도록 할 수도 있지만 선언하는 것이 좋다). 아래의 코드는 integer를 받아 integer를 돌려주는 <code class=\"language-text\">square</code>라는 함수를 생성한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"elm\"><pre class=\"language-elm\"><code class=\"language-elm\"><span class=\"token hvariable\">square</span> <span class=\"token operator\">:</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token hvariable\">square</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">x</span></code></pre></div>\n<p>만약 같은 함수를 JavaScript로 만든다면 다음과 같을 것이다:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">square</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">x</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> x <span class=\"token operator\">*</span> x<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Elm 코드의 제일 첫 라인에 주목해보자:</p>\n<div class=\"gatsby-highlight\" data-language=\"elm\"><pre class=\"language-elm\"><code class=\"language-elm\"><span class=\"token hvariable\">square</span> <span class=\"token operator\">:</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span></code></pre></div>\n<p>이것은 <strong>type annotation</strong>으로, 이 함수가 하나의 integer를 받아 하나의 integer를 돌려주는 함수라는 것을 Elm—정확히는 컴파일러—에게 알려준다. 만약 다른 타입의 값을 함수에 넣으면 에러를 발생시킬 것이다. 이런 제한 때문에 시간이 조금 더 걸리겠지만 훨씬 깔끔하고 이해하기 쉬운 코드가 된다.</p>\n<h2 id=\"컴파일compiling\" style=\"position:relative;\"><a href=\"#%EC%BB%B4%ED%8C%8C%EC%9D%BCcompiling\" aria-label=\"컴파일compiling permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>컴파일(Compiling)</h2>\n<p>함수를 잘못된 타입 값으로 호출하려고 한다면 에러가 날 것이라고 위에서 이야기했었다. 심지어 더 좋은 건, <strong>컴파일 시간</strong>에 에러를 낸다는 점이다. Elm은 JavaScript로 컴파일하므로 Elm 코드를 받아 JavaScript 코드를 생성해주는 컴파일러를 실행해야 한다. Elm의 컴파일러는 똑똑해서 JavaScript로 코드를 생성할 때 타입을 검사한다. 예를 들어, 다음의 코드를 컴파일한다면 에러가 발생할 것이다. 세세한 문법에 대해서는 걱정하지 말고 <code class=\"language-text\">square</code>함수에 “Hello”를 넣는다는 것을 기억하자.</p>\n<div class=\"gatsby-highlight\" data-language=\"elm\"><pre class=\"language-elm\"><code class=\"language-elm\"><span class=\"token hvariable\">square</span> <span class=\"token operator\">:</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>\n<span class=\"token hvariable\">square</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">x</span>\n\n<span class=\"token hvariable\">main</span> <span class=\"token operator\">=</span>\n  <span class=\"token hvariable\">square</span> <span class=\"token string\">\"Hello\"</span></code></pre></div>\n<p>다음이 컴파일러가 발생시키는 에러이다:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">The argument to function `square` is causing a mismatch.\n\n5│   square &quot;Hello&quot;\n            ^^^^^^^\nFunction `square` is expecting the argument to be:\n\n    Int\n\nBut it is:\n\n    String</code></pre></div>\n<p>멋지지 않은가?! 브라우저에서 코드를 실행할 때 이상한 에러를 보여주는 대신, 컴파일러가 미리 실수를 발견해서 에러를 보여준다.</p>\n<h2 id=\"elm-시작하기\" style=\"position:relative;\"><a href=\"#elm-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0\" aria-label=\"elm 시작하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Elm 시작하기</h2>\n<p>이 글이 Elm에 대한 호기심을 자극했기를 바란다. 곧 Elm에 대한 혹은 어떻게 시작할지에 대한 글을 더 쓸 예정이다. 하지만 혹시나 미리 더 많은 정보를 보고 싶다면 아래의 글들을 추천한다.</p>\n<ul>\n<li><a href=\"http://elm-lang.org/docs/from-javascript\">Comparison of Elm and JS Syntax</a></li>\n<li><a href=\"http://elm-lang.org/docs/syntax\">Elm syntax introduction</a></li>\n<li><a href=\"https://pragmaticstudio.com/elm\">Elm video course ($24 이지만 추천)</a></li>\n<li><a href=\"https://github.com/jackfranklin/elm-game-of-life\">My Game of Life implementation in Elm</a></li>\n<li><a href=\"https://github.com/jackfranklin/elm-connect-four\">Connect Four in Elm</a></li>\n</ul>","frontmatter":{"title":"JavaScript 개발자를 위한 Elm","category":"translation","date":"November 28, 2015","updated":null,"description":null,"tags":["JavaScript","Elm"]}},"previous":{"fields":{"slug":"/translation/redux-hot-reloading-and-time-travel-debugging/"},"frontmatter":{"title":"핫 리로딩(hot reloading)과 시간 여행 디버깅(time travel debugging)이 도대체 무엇일까?"}},"next":null},"pageContext":{"id":"3303e207-a0ea-5530-b1ff-1822c9d586b9","previousPostId":"89730a12-5cb1-559f-87ad-e9c144d489b6","nextPostId":null}},"staticQueryHashes":["2841359383"]}