{"componentChunkName":"component---src-templates-blog-post-js","path":"/translation/redux-hot-reloading-and-time-travel-debugging/","result":{"data":{"site":{"siteMetadata":{"title":"bestalign's dev blog","categories":[{"displayText":"홈","priority":0,"name":"home","url":"/"},{"displayText":"TIL","priority":1,"name":"til","url":"/til"},{"displayText":"개발","priority":2,"name":"dev","url":"/dev"},{"displayText":"독서","priority":3,"name":"reading","url":"/reading"},{"displayText":"번역","priority":4,"name":"translation","url":"/translation"},{"displayText":"일기","priority":5,"name":"everydaylife","url":"/everydaylife"}]}},"markdownRemark":{"id":"89730a12-5cb1-559f-87ad-e9c144d489b6","excerpt":"원문: https://code-cartoons.com/hot-reloading-and-time-travel-debugging-what-are-they-3c8ed2812f35 사람들이 열광하는 Redux의 두 가지 기능은 핫 리로딩(hot reloading)과 시간 여행 디버깅(time…","html":"<p>원문: <a href=\"https://code-cartoons.com/hot-reloading-and-time-travel-debugging-what-are-they-3c8ed2812f35\">https://code-cartoons.com/hot-reloading-and-time-travel-debugging-what-are-they-3c8ed2812f35</a></p>\n<p>사람들이 열광하는 Redux의 두 가지 기능은 핫 리로딩(hot reloading)과 시간 여행 디버깅(time travel debugging)이다. 이 둘은 과연 무엇일까?</p>\n<h3 id=\"핫-리로딩hot-reloading\" style=\"position:relative;\"><a href=\"#%ED%95%AB-%EB%A6%AC%EB%A1%9C%EB%94%A9hot-reloading\" aria-label=\"핫 리로딩hot reloading permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>핫 리로딩(hot reloading)</h3>\n<p>애플리케이션을 개발할 때는 일반적으로 코드를 조금씩 수정해가면서 만들게 된다. 매 수정 뒤에 결과를 빨리 확인할 수 있으면 (그리고 작은 실수를 했을 때 고친 뒤 빨리 확인할 수 있다면), 개발 속도를 올릴 수 있을 것이다.</p>\n<p>핫 리로딩의 멋진 점은 매 수정 뒤에도 애플리케이션의 상태가 사라지지 않는다는 점이다. todo 애플리케이션의 특정 화면을 테스트한다고 해보자. todo 아이템을 몇 개 추가하고 그 중 몇개는 완료처리를 했는데 그 뒤에 보니 UI 텍스트를 수정을 해야 하는 상황이다. 예를 들어, 플레이스홀더(placeholder)를 “New toto”에서 “New todo”로 수정해야 한다.</p>\n<p>핫 리로딩이 없다면, 다음과 같이 해야 할 것이다:</p>\n<ul>\n<li>코드를 수정한다</li>\n<li>브라우저의 페이지를 새로고침한다</li>\n<li>데이터를 재입력한다</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/2184127da10c0ce13d958e387ef2f37d/8c557/1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 29.746835443037973%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAABA0lEQVQY03WQXUrDUBCFswdxOe7A9air8FXf3II+CIIgqKBt7Utb2oCptilNGpP0Jrm/yeTeuXIbKEVw+B6GwzlnYLz7KfkIWW9Bewv6lasf2ly/bo7PB/0ltdYaxJTBw4wMQmd4CaoglSmDi7vl0Vnfe56XfiInsRhFPC6brYDbUX5yOR6umN1NxuDtuxpHfBLxYUjXZUMk3Lwnp1czjwggAgrZStC01pXSEnRrDFqsWxNkEtEtEhwKDKs1Vbp2DvSePsvpRswztTuD1iJa1GistXHVPPqFNqYTO/YeF46rZsthXbgug7gHLSowOYdD8Q+en4gVqccRr1vT9R3S/ey/8C90gU/Tf4WmMQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"핫 리로딩이 없다면 리로딩 시  todo 리스트는 모두 사라진다.\"\n        title=\"핫 리로딩이 없다면 리로딩 시  todo 리스트는 모두 사라진다.\"\n        src=\"/static/2184127da10c0ce13d958e387ef2f37d/f058b/1.png\"\n        srcset=\"/static/2184127da10c0ce13d958e387ef2f37d/c26ae/1.png 158w,\n/static/2184127da10c0ce13d958e387ef2f37d/6bdcf/1.png 315w,\n/static/2184127da10c0ce13d958e387ef2f37d/f058b/1.png 630w,\n/static/2184127da10c0ce13d958e387ef2f37d/8c557/1.png 700w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>핫 리로딩이 사용 가능 하다면 애플리케이션의 상태를 잃어버리지 않기 때문에 데이터를 재입력할 필요가 없다. 모든 todo 리스트가 그대로 유지될 것이고 그만큼 디버깅의 시간이 아주 절약될 것이다.</p>\n<p>React 애플리케이션이 데이터를 관리하기 위해 Redux를 사용하지 않는다고 해도 핫 리로딩을 사용할 수는 있다. 핫 리로딩하는 것에 약간의 제약이 생길 뿐이다. 뷰(view)와 액션 생성자(action creator)는 핫 리로딩할 수 있다. 하지만 스토어(store)는 불가능하다. 이것은 스토어가 두 가지 역할을 맡고 있기 때문이다. 애플리케이션 상태를 가지고 있는 것과 그 상태를 액션에 따라 업데이트 하는 것이 바로 그것이다. 상태 업데이트에 관련 된 코드를 리로딩하게 되면 애플리케이션 상태도 같이 리로딩되기 때문에 저장된 상태 정보를 잃어버리게 된다.</p>\n<p>Redux가 유용한 점이 바로 상태 변환 로직을 핫 리로딩할 수 있다는 점이다. 그리고 그것은 바로 위의 두 가지 역할을 분리함으로써 가능하다. Redux에서는 스토어가 애플리케이션 상태를 가지고, 상태 변환 로직은 또 다른 객체인 리듀서(reducer)가 관리를 하게 된다. 다시말해서 리듀서를 리로딩하는 것으로 애플리케이션 상태를 잃어버리지 않고 관련 로직만을 핫 리로딩 할 수 있다는 뜻이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7f6eaf27a32009a481254d0894b2e3c4/8c557/2.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 29.746835443037973%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAIAAABM9SnKAAAACXBIWXMAAAsTAAALEwEAmpwYAAABF0lEQVQY012PS07DMBCGcwfEcbgB5wFOwRZ2SJwAFogdErCAPpBoUVKJFGijNG7Sxk0cv2OPkRMJEKN/+X3/zAQ3IR4tyfOXz8dW5ESdP6L94+FgQZxz4KBo9G2Ehx3zENdxwYtGn1wv9o4GwX1czdb8bUUnKc0qVTJ9NdkenE7HSeO6KakeL5sQsRDR0ZKklcJcXzytD8+iADONmd7xlmtDpKmF4dq01gKAMjarFRFthBiqVU6UbC2RhggjOyK4e69CxOYb0a0B5wAcGGudc68pvRzkmLUvSTPfiKxW/SM94+WsViXV6c53WYCfgAOmjND+kEUpskrNN/wv4OXZmiVYTldUtrbv+/XBL6HKfG5F0egEy3/yN0GbTRA1DmvHAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Redux 핫 리로딩이 있으면 애플리케이션 상태를 잃어버리지 않는다.\"\n        title=\"Redux 핫 리로딩이 있으면 애플리케이션 상태를 잃어버리지 않는다.\"\n        src=\"/static/7f6eaf27a32009a481254d0894b2e3c4/f058b/2.png\"\n        srcset=\"/static/7f6eaf27a32009a481254d0894b2e3c4/c26ae/2.png 158w,\n/static/7f6eaf27a32009a481254d0894b2e3c4/6bdcf/2.png 315w,\n/static/7f6eaf27a32009a481254d0894b2e3c4/f058b/2.png 630w,\n/static/7f6eaf27a32009a481254d0894b2e3c4/8c557/2.png 700w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h3 id=\"시간-여행-디버깅time-travel-debugging\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84-%EC%97%AC%ED%96%89-%EB%94%94%EB%B2%84%EA%B9%85time-travel-debugging\" aria-label=\"시간 여행 디버깅time travel debugging permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간 여행 디버깅(time travel debugging)</h3>\n<p>핫 리로딩은 코드가 바뀌었을 때도 기존의 상태를 유지할 수 있게 만들어준다. 시간 여행 디버깅은 이전의 특정 상태로 돌아갈 수 있게 해준다.</p>\n<p>시간 여행 디버깅을 하면 애플리케이션과의 특정 상호작용(interaction)을 빠르게 테스트할 수 있다. 예를 들어, todo 아이템을 하나 완료처리 한 후 또 다른 todo 아이템을 추가했을 때 버그가 있다고 가정하자. 먼저 알려진 시나리오를 따라서 그 버그를 재현한다. 그다음 단순히 바로 이전의 애플리케이션 상태로 돌아간 뒤 다시 새로운 todo 아이템을 추가함으로써 기능을 테스트할 수 있다. [핫 리로딩으로 코드를 업데이트한 후 바로 테스트할 수 있으므로 아주 편리하다.]</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b10ae5266a2b9e80c427d50c15f167db/8c557/3.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.12658227848101%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB1ElEQVQoz1WSzW4UMQzH54058QqIF+EEEpyQekCIEwe0LUh0u1u2292d7e58JzOZxLGdD5SZFtocHDny3/7ZThafnRCSHYCbkQbg3nAPXCsCcvHlCSH4ELJloVel2bVwfdZvLnJl3bnHZqRDZ/9U6f0osNXJXZXmpjBHYd9e5LeViTFm68KsS/Mg8b6Bdz+qeqSjtL3lcsBKITpPPqxLsy7175PetdCM9OGyyYVN4pcs6WpHmot3OpEXAyp0IzppeA74j/3PCY/aKDSXilpNxYDnHvedBfbPNTFGH4LzPlsc1GWu1qVZHNSr99tO83nAGf7Q2YOwm9rUI20quMrHX8dx39nXH++XJ52wbwp914AErkf6vh2E4QdppWFDjn2q0wPnKQUsz7pS1ANf5WqxV9sGshHZPlI99axTz5WickYQ1rLX6CRwiHFu7STx0882k8DCsDRpt4tchRDQpVBgb9kDuwnBo/NAfrDJXZfGh/D5ustyYYse+wn720Yi+wESs7JOTJ9EGAb29bT5k0QJ/PVW7Fr4shJZq0mjm+cdY1TW9cAak7IZiVJB12qShltN/mnapx5zYbN5+m6y5FLzg2VlUzVDSSmByXtDrtOEzocpbM7yF3FIrDX+JoLnAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"시간 여행 디버깅은 상태 히스토리에 있는 여러 상태들을 왔다갔다 쉽게 이동할 수 있다.\"\n        title=\"시간 여행 디버깅은 상태 히스토리에 있는 여러 상태들을 왔다갔다 쉽게 이동할 수 있다.\"\n        src=\"/static/b10ae5266a2b9e80c427d50c15f167db/f058b/3.png\"\n        srcset=\"/static/b10ae5266a2b9e80c427d50c15f167db/c26ae/3.png 158w,\n/static/b10ae5266a2b9e80c427d50c15f167db/6bdcf/3.png 315w,\n/static/b10ae5266a2b9e80c427d50c15f167db/f058b/3.png 630w,\n/static/b10ae5266a2b9e80c427d50c15f167db/8c557/3.png 700w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>그 외에도 멋지게 활용할 수 있는 곳이 또 있다. QA 테스터가 하는 모든 액션을 저장할 수 있다. 만약 QA 테스터가 버그를 발견하면, 액션과 애플리케이션 상태 히스토리(history)를 간단히 저장하면 된다. 또한 자동화 테스트(automated test)에도 적용 가능하다. [저장한 상태 히스토리로 쉽게 버그를 재현하고 고칠 수 있다.]</p>\n<p>시간 여행 디버깅은 기술적으로 Flux에도 가능하지만 구현이 복잡한 반면, Redux에서는 아주 간단히 할 수 있다.</p>\n<h2 id=\"이어지는-글\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%96%B4%EC%A7%80%EB%8A%94-%EA%B8%80\" aria-label=\"이어지는 글 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이어지는 글</h2>\n<p>Redux가 어떻게 동작하는지 보자: <a href=\"/cartoon-intro-to-redux\">Redux로의 카툰 안내서</a></p>","frontmatter":{"title":"핫 리로딩(hot reloading)과 시간 여행 디버깅(time travel debugging)이 도대체 무엇일까?","category":"translation","date":"October 27, 2015","updated":null,"description":null,"tags":["Redux","JavaScript","Flux","Hot Reloading","Time Travel Debugging"]}},"previous":{"fields":{"slug":"/translation/cartoon-intro-to-redux/"},"frontmatter":{"title":"Redux로의 카툰 안내서"}},"next":{"fields":{"slug":"/translation/elm-for-javascript-developers/"},"frontmatter":{"title":"JavaScript 개발자를 위한 Elm"}}},"pageContext":{"id":"89730a12-5cb1-559f-87ad-e9c144d489b6","previousPostId":"94aa8a35-f457-5d8d-86c3-0eafab4addf3","nextPostId":"3303e207-a0ea-5530-b1ff-1822c9d586b9"}},"staticQueryHashes":["2841359383"]}